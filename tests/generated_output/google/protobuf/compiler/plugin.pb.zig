// Code generated by protoc-gen-zig-go

const std = @import("std");
const mem = std.mem;
const Allocator = mem.Allocator;
const ArrayList = std.ArrayList;

const protobuf = @import("protobuf");
const FieldDescriptor = protobuf.FieldDescriptor;
const pb_decode = protobuf.pb_decode;
const pb_encode = protobuf.pb_encode;
const pb_deinit = protobuf.pb_deinit;
const pb_init = protobuf.pb_init;
const fd = protobuf.fd;

const google_protobuf_descriptor_proto = @import("../../protobuf/descriptor.pb.zig");
// The version number of protocol compiler.
pub const Version = struct {
    major: ?i32,
    minor: ?i32,
    patch: ?i32,
    // A suffix for alpha, beta or rc release, e.g., "alpha-1", "rc2". It should
    // be empty for mainline stable releases.
    suffix: ?[]const u8,

    pub const _desc_table = .{
        .major = fd(1, .{ .Varint = .Simple }, ?i32),
        .minor = fd(2, .{ .Varint = .Simple }, ?i32),
        .patch = fd(3, .{ .Varint = .Simple }, ?i32),
        .suffix = fd(4, .String, ?[]const u8),
    };

    pub fn encode(self: Version, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }

    pub fn decode(input: []const u8, allocator: Allocator) !Version {
        return pb_decode(Version, input, allocator);
    }

    pub fn init(allocator: Allocator) Version {
        return pb_init(Version, allocator);
    }

    pub fn deinit(self: Version) void {
        return pb_deinit(self);
    }
};

// An encoded CodeGeneratorRequest is written to the plugin's stdin.
pub const CodeGeneratorRequest = struct {
    // The .proto files that were explicitly listed on the command-line.  The
    // code generator should generate code only for these files.  Each file's
    // descriptor will be included in proto_file, below.
    file_to_generate: ArrayList([]const u8),
    // The generator parameter passed on the command-line.
    parameter: ?[]const u8,
    // FileDescriptorProtos for all files in files_to_generate and everything
    // they import.  The files will appear in topological order, so each file
    // appears before any file that imports it.
    //
    // protoc guarantees that all proto_files will be written after
    // the fields above, even though this is not technically guaranteed by the
    // protobuf wire format.  This theoretically could allow a plugin to stream
    // in the FileDescriptorProtos and handle them one by one rather than read
    // the entire set into memory at once.  However, as of this writing, this
    // is not similarly optimized on protoc's end -- it will store all fields in
    // memory at once before sending them to the plugin.
    //
    // Type names of fields and extensions in the FileDescriptorProto are always
    // fully qualified.
    proto_file: ArrayList(google_protobuf_descriptor_proto.FileDescriptorProto),
    // The version number of protocol compiler.
    compiler_version: ?Version,

    pub const _desc_table = .{
        .file_to_generate = fd(1, .{ .List = .String }, ArrayList([]const u8)),
        .parameter = fd(2, .String, ?[]const u8),
        .proto_file = fd(15, .{ .List = .SubMessage }, ArrayList(google_protobuf_descriptor_proto.FileDescriptorProto)),
        .compiler_version = fd(3, .{ .SubMessage = {} }, ?Version),
    };

    pub fn encode(self: CodeGeneratorRequest, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }

    pub fn decode(input: []const u8, allocator: Allocator) !CodeGeneratorRequest {
        return pb_decode(CodeGeneratorRequest, input, allocator);
    }

    pub fn init(allocator: Allocator) CodeGeneratorRequest {
        return pb_init(CodeGeneratorRequest, allocator);
    }

    pub fn deinit(self: CodeGeneratorRequest) void {
        return pb_deinit(self);
    }
};

// The plugin writes an encoded CodeGeneratorResponse to stdout.
pub const CodeGeneratorResponse = struct {
    // Error message.  If non-empty, code generation failed.  The plugin process
    // should exit with status code zero even if it reports an error in this way.
    //
    // This should be used to indicate errors in .proto files which prevent the
    // code generator from generating correct code.  Errors which indicate a
    // problem in protoc itself -- such as the input CodeGeneratorRequest being
    // unparseable -- should be reported by writing a message to stderr and
    // exiting with a non-zero status code.
    @"error": ?[]const u8,
    // A bitmask of supported features that the code generator supports.
    // This is a bitwise "or" of values from the Feature enum.
    supported_features: ?u64,
    file: ArrayList(File),
    // Sync with code_generator.h.
    pub const Feature = enum(i32) {
        FEATURE_NONE = 0,
        FEATURE_PROTO3_OPTIONAL = 1,
        _,
    };

    // Represents a single generated file.
    pub const File = struct {
        // The file name, relative to the output directory.  The name must not
        // contain "." or ".." components and must be relative, not be absolute (so,
        // the file cannot lie outside the output directory).  "/" must be used as
        // the path separator, not "\".
        //
        // If the name is omitted, the content will be appended to the previous
        // file.  This allows the generator to break large files into small chunks,
        // and allows the generated text to be streamed back to protoc so that large
        // files need not reside completely in memory at one time.  Note that as of
        // this writing protoc does not optimize for this -- it will read the entire
        // CodeGeneratorResponse before writing files to disk.
        name: ?[]const u8,
        // If non-empty, indicates that the named file should already exist, and the
        // content here is to be inserted into that file at a defined insertion
        // point.  This feature allows a code generator to extend the output
        // produced by another code generator.  The original generator may provide
        // insertion points by placing special annotations in the file that look
        // like:
        //   @@protoc_insertion_point(NAME)
        // The annotation can have arbitrary text before and after it on the line,
        // which allows it to be placed in a comment.  NAME should be replaced with
        // an identifier naming the point -- this is what other generators will use
        // as the insertion_point.  Code inserted at this point will be placed
        // immediately above the line containing the insertion point (thus multiple
        // insertions to the same point will come out in the order they were added).
        // The double-@ is intended to make it unlikely that the generated code
        // could contain things that look like insertion points by accident.
        //
        // For example, the C++ code generator places the following line in the
        // .pb.h files that it generates:
        //   // @@protoc_insertion_point(namespace_scope)
        // This line appears within the scope of the file's package namespace, but
        // outside of any particular class.  Another plugin can then specify the
        // insertion_point "namespace_scope" to generate additional classes or
        // other declarations that should be placed in this scope.
        //
        // Note that if the line containing the insertion point begins with
        // whitespace, the same whitespace will be added to every line of the
        // inserted text.  This is useful for languages like Python, where
        // indentation matters.  In these languages, the insertion point comment
        // should be indented the same amount as any inserted code will need to be
        // in order to work correctly in that context.
        //
        // The code generator that generates the initial file and the one which
        // inserts into it must both run as part of a single invocation of protoc.
        // Code generators are executed in the order in which they appear on the
        // command line.
        //
        // If |insertion_point| is present, |name| must also be present.
        insertion_point: ?[]const u8,
        // The file contents.
        content: ?[]const u8,
        // Information describing the file content being inserted. If an insertion
        // point is used, this information will be appropriately offset and inserted
        // into the code generation metadata for the generated files.
        generated_code_info: ?google_protobuf_descriptor_proto.GeneratedCodeInfo,

        pub const _desc_table = .{
            .name = fd(1, .String, ?[]const u8),
            .insertion_point = fd(2, .String, ?[]const u8),
            .content = fd(15, .String, ?[]const u8),
            .generated_code_info = fd(16, .{ .SubMessage = {} }, ?google_protobuf_descriptor_proto.GeneratedCodeInfo),
        };

        pub fn encode(self: File, allocator: Allocator) ![]u8 {
            return pb_encode(self, allocator);
        }

        pub fn decode(input: []const u8, allocator: Allocator) !File {
            return pb_decode(File, input, allocator);
        }

        pub fn init(allocator: Allocator) File {
            return pb_init(File, allocator);
        }

        pub fn deinit(self: File) void {
            return pb_deinit(self);
        }
    };

    pub const _desc_table = .{
        .@"error" = fd(1, .String, ?[]const u8),
        .supported_features = fd(2, .{ .Varint = .Simple }, ?u64),
        .file = fd(15, .{ .List = .SubMessage }, ArrayList(File)),
    };

    pub fn encode(self: CodeGeneratorResponse, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }

    pub fn decode(input: []const u8, allocator: Allocator) !CodeGeneratorResponse {
        return pb_decode(CodeGeneratorResponse, input, allocator);
    }

    pub fn init(allocator: Allocator) CodeGeneratorResponse {
        return pb_init(CodeGeneratorResponse, allocator);
    }

    pub fn deinit(self: CodeGeneratorResponse) void {
        return pb_deinit(self);
    }
};
