// Code generated by protoc-gen-zig
///! package jspb.test
const std = @import("std");
const mem = std.mem;
const Allocator = mem.Allocator;
const ArrayList = std.ArrayList;

const protobuf = @import("protobuf");
const pb_decode = protobuf.pb_decode;
const pb_encode = protobuf.pb_encode;
const pb_deinit = protobuf.pb_deinit;
const pb_init = protobuf.pb_init;
const fd = protobuf.fd;
/// import package google.protobuf
const google_protobuf = @import("../google/protobuf.pb.zig");

pub const OuterEnum = enum(i32) {
    FOO = 1,
    BAR = 2,
    _,
};

pub const MapValueEnumNoBinary = enum(i32) {
    MAP_VALUE_FOO_NOBINARY = 0,
    MAP_VALUE_BAR_NOBINARY = 1,
    MAP_VALUE_BAZ_NOBINARY = 2,
    _,
};

pub const Empty = struct {
    pub const _desc_table = .{};

    pub fn encode(self: Empty, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !Empty {
        return pb_decode(Empty, input, allocator);
    }
    pub fn init(allocator: Allocator) Empty {
        return pb_init(Empty, allocator);
    }
    pub fn deinit(self: Empty) void {
        return pb_deinit(self);
    }
};

pub const EnumContainer = struct {
    outer_enum: ?OuterEnum,

    pub const _desc_table = .{
        .outer_enum = fd(1, .{ .Varint = .Simple }),
    };

    pub fn encode(self: EnumContainer, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !EnumContainer {
        return pb_decode(EnumContainer, input, allocator);
    }
    pub fn init(allocator: Allocator) EnumContainer {
        return pb_init(EnumContainer, allocator);
    }
    pub fn deinit(self: EnumContainer) void {
        return pb_deinit(self);
    }
};

pub const Simple1 = struct {
    a_string: ?[]const u8,
    a_repeated_string: ArrayList([]const u8),
    a_boolean: ?bool,

    pub const _desc_table = .{
        .a_string = fd(1, .String),
        .a_repeated_string = fd(2, .{ .List = .String }),
        .a_boolean = fd(3, .{ .Varint = .Simple }),
    };

    pub fn encode(self: Simple1, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !Simple1 {
        return pb_decode(Simple1, input, allocator);
    }
    pub fn init(allocator: Allocator) Simple1 {
        return pb_init(Simple1, allocator);
    }
    pub fn deinit(self: Simple1) void {
        return pb_deinit(self);
    }
};

pub const Simple2 = struct {
    a_string: ?[]const u8,
    a_repeated_string: ArrayList([]const u8),

    pub const _desc_table = .{
        .a_string = fd(1, .String),
        .a_repeated_string = fd(2, .{ .List = .String }),
    };

    pub fn encode(self: Simple2, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !Simple2 {
        return pb_decode(Simple2, input, allocator);
    }
    pub fn init(allocator: Allocator) Simple2 {
        return pb_init(Simple2, allocator);
    }
    pub fn deinit(self: Simple2) void {
        return pb_deinit(self);
    }
};

pub const SpecialCases = struct {
    normal: ?[]const u8,
    default: ?[]const u8,
    function: ?[]const u8,
    @"var": ?[]const u8,

    pub const _desc_table = .{
        .normal = fd(1, .String),
        .default = fd(2, .String),
        .function = fd(3, .String),
        .@"var" = fd(4, .String),
    };

    pub fn encode(self: SpecialCases, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !SpecialCases {
        return pb_decode(SpecialCases, input, allocator);
    }
    pub fn init(allocator: Allocator) SpecialCases {
        return pb_init(SpecialCases, allocator);
    }
    pub fn deinit(self: SpecialCases) void {
        return pb_deinit(self);
    }
};

pub const OptionalFields = struct {
    a_string: ?[]const u8,
    a_bool: bool,
    a_nested_message: ?Nested,
    a_repeated_message: ArrayList(Nested),
    a_repeated_string: ArrayList([]const u8),

    pub const _desc_table = .{
        .a_string = fd(1, .String),
        .a_bool = fd(2, .{ .Varint = .Simple }),
        .a_nested_message = fd(3, .{ .SubMessage = {} }),
        .a_repeated_message = fd(4, .{ .List = .{ .SubMessage = {} } }),
        .a_repeated_string = fd(5, .{ .List = .String }),
    };

    pub const Nested = struct {
        an_int: ?i32,

        pub const _desc_table = .{
            .an_int = fd(1, .{ .Varint = .Simple }),
        };

        pub fn encode(self: Nested, allocator: Allocator) ![]u8 {
            return pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) !Nested {
            return pb_decode(Nested, input, allocator);
        }
        pub fn init(allocator: Allocator) Nested {
            return pb_init(Nested, allocator);
        }
        pub fn deinit(self: Nested) void {
            return pb_deinit(self);
        }
    };

    pub fn encode(self: OptionalFields, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !OptionalFields {
        return pb_decode(OptionalFields, input, allocator);
    }
    pub fn init(allocator: Allocator) OptionalFields {
        return pb_init(OptionalFields, allocator);
    }
    pub fn deinit(self: OptionalFields) void {
        return pb_deinit(self);
    }
};

pub const HasExtensions = struct {
    str1: ?[]const u8,
    str2: ?[]const u8,
    str3: ?[]const u8,

    pub const _desc_table = .{
        .str1 = fd(1, .String),
        .str2 = fd(2, .String),
        .str3 = fd(3, .String),
    };

    pub fn encode(self: HasExtensions, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !HasExtensions {
        return pb_decode(HasExtensions, input, allocator);
    }
    pub fn init(allocator: Allocator) HasExtensions {
        return pb_init(HasExtensions, allocator);
    }
    pub fn deinit(self: HasExtensions) void {
        return pb_deinit(self);
    }
};

pub const Complex = struct {
    a_string: ?[]const u8,
    an_out_of_order_bool: bool,
    a_nested_message: ?Nested,
    a_repeated_message: ArrayList(Nested),
    a_repeated_string: ArrayList([]const u8),

    pub const _desc_table = .{
        .a_string = fd(1, .String),
        .an_out_of_order_bool = fd(9, .{ .Varint = .Simple }),
        .a_nested_message = fd(4, .{ .SubMessage = {} }),
        .a_repeated_message = fd(5, .{ .List = .{ .SubMessage = {} } }),
        .a_repeated_string = fd(7, .{ .List = .String }),
    };

    pub const Nested = struct {
        an_int: i32,

        pub const _desc_table = .{
            .an_int = fd(2, .{ .Varint = .Simple }),
        };

        pub fn encode(self: Nested, allocator: Allocator) ![]u8 {
            return pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) !Nested {
            return pb_decode(Nested, input, allocator);
        }
        pub fn init(allocator: Allocator) Nested {
            return pb_init(Nested, allocator);
        }
        pub fn deinit(self: Nested) void {
            return pb_deinit(self);
        }
    };

    pub fn encode(self: Complex, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !Complex {
        return pb_decode(Complex, input, allocator);
    }
    pub fn init(allocator: Allocator) Complex {
        return pb_init(Complex, allocator);
    }
    pub fn deinit(self: Complex) void {
        return pb_deinit(self);
    }
};

pub const IsExtension = struct {
    ext1: ?[]const u8,

    pub const _desc_table = .{
        .ext1 = fd(1, .String),
    };

    pub fn encode(self: IsExtension, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !IsExtension {
        return pb_decode(IsExtension, input, allocator);
    }
    pub fn init(allocator: Allocator) IsExtension {
        return pb_init(IsExtension, allocator);
    }
    pub fn deinit(self: IsExtension) void {
        return pb_deinit(self);
    }
};

pub const IndirectExtension = struct {
    pub const _desc_table = .{};

    pub fn encode(self: IndirectExtension, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !IndirectExtension {
        return pb_decode(IndirectExtension, input, allocator);
    }
    pub fn init(allocator: Allocator) IndirectExtension {
        return pb_init(IndirectExtension, allocator);
    }
    pub fn deinit(self: IndirectExtension) void {
        return pb_deinit(self);
    }
};

pub const DefaultValues = struct {
    string_field: ?[]const u8,
    bool_field: ?bool,
    int_field: ?i64,
    enum_field: ?Enum,
    empty_field: ?[]const u8,
    bytes_field: ?[]const u8,

    pub const _desc_table = .{
        .string_field = fd(1, .String),
        .bool_field = fd(2, .{ .Varint = .Simple }),
        .int_field = fd(3, .{ .Varint = .Simple }),
        .enum_field = fd(4, .{ .Varint = .Simple }),
        .empty_field = fd(6, .String),
        .bytes_field = fd(8, .String),
    };

    pub const Enum = enum(i32) {
        E1 = 13,
        E2 = 77,
        _,
    };

    pub fn encode(self: DefaultValues, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !DefaultValues {
        return pb_decode(DefaultValues, input, allocator);
    }
    pub fn init(allocator: Allocator) DefaultValues {
        return pb_init(DefaultValues, allocator);
    }
    pub fn deinit(self: DefaultValues) void {
        return pb_deinit(self);
    }
};

pub const FloatingPointFields = struct {
    optional_float_field: ?f32,
    required_float_field: f32,
    repeated_float_field: ArrayList(f32),
    default_float_field: ?f32,
    optional_double_field: ?f64,
    required_double_field: f64,
    repeated_double_field: ArrayList(f64),
    default_double_field: ?f64,

    pub const _desc_table = .{
        .optional_float_field = fd(1, .{ .FixedInt = .I32 }),
        .required_float_field = fd(2, .{ .FixedInt = .I32 }),
        .repeated_float_field = fd(3, .{ .List = .{ .FixedInt = .I32 } }),
        .default_float_field = fd(4, .{ .FixedInt = .I32 }),
        .optional_double_field = fd(5, .{ .FixedInt = .I64 }),
        .required_double_field = fd(6, .{ .FixedInt = .I64 }),
        .repeated_double_field = fd(7, .{ .List = .{ .FixedInt = .I64 } }),
        .default_double_field = fd(8, .{ .FixedInt = .I64 }),
    };

    pub fn encode(self: FloatingPointFields, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !FloatingPointFields {
        return pb_decode(FloatingPointFields, input, allocator);
    }
    pub fn init(allocator: Allocator) FloatingPointFields {
        return pb_init(FloatingPointFields, allocator);
    }
    pub fn deinit(self: FloatingPointFields) void {
        return pb_deinit(self);
    }
};

pub const TestClone = struct {
    str: ?[]const u8,
    simple1: ?Simple1,
    simple2: ArrayList(Simple1),
    bytes_field: ?[]const u8,
    unused: ?[]const u8,

    pub const _desc_table = .{
        .str = fd(1, .String),
        .simple1 = fd(3, .{ .SubMessage = {} }),
        .simple2 = fd(5, .{ .List = .{ .SubMessage = {} } }),
        .bytes_field = fd(6, .String),
        .unused = fd(7, .String),
    };

    pub fn encode(self: TestClone, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestClone {
        return pb_decode(TestClone, input, allocator);
    }
    pub fn init(allocator: Allocator) TestClone {
        return pb_init(TestClone, allocator);
    }
    pub fn deinit(self: TestClone) void {
        return pb_deinit(self);
    }
};

pub const CloneExtension = struct {
    ext: ?[]const u8,

    pub const _desc_table = .{
        .ext = fd(2, .String),
    };

    pub fn encode(self: CloneExtension, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !CloneExtension {
        return pb_decode(CloneExtension, input, allocator);
    }
    pub fn init(allocator: Allocator) CloneExtension {
        return pb_init(CloneExtension, allocator);
    }
    pub fn deinit(self: CloneExtension) void {
        return pb_deinit(self);
    }
};

pub const TestGroup = struct {
    id: ?[]const u8,
    required_simple: ?Simple2,
    optional_simple: ?Simple2,

    pub const _desc_table = .{
        .id = fd(6, .String),
        .required_simple = fd(7, .{ .SubMessage = {} }),
        .optional_simple = fd(8, .{ .SubMessage = {} }),
    };

    pub fn encode(self: TestGroup, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestGroup {
        return pb_decode(TestGroup, input, allocator);
    }
    pub fn init(allocator: Allocator) TestGroup {
        return pb_init(TestGroup, allocator);
    }
    pub fn deinit(self: TestGroup) void {
        return pb_deinit(self);
    }
};

pub const TestReservedNames = struct {
    extension: ?i32,

    pub const _desc_table = .{
        .extension = fd(1, .{ .Varint = .Simple }),
    };

    pub fn encode(self: TestReservedNames, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestReservedNames {
        return pb_decode(TestReservedNames, input, allocator);
    }
    pub fn init(allocator: Allocator) TestReservedNames {
        return pb_init(TestReservedNames, allocator);
    }
    pub fn deinit(self: TestReservedNames) void {
        return pb_deinit(self);
    }
};

pub const TestReservedNamesExtension = struct {
    pub const _desc_table = .{};

    pub fn encode(self: TestReservedNamesExtension, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestReservedNamesExtension {
        return pb_decode(TestReservedNamesExtension, input, allocator);
    }
    pub fn init(allocator: Allocator) TestReservedNamesExtension {
        return pb_init(TestReservedNamesExtension, allocator);
    }
    pub fn deinit(self: TestReservedNamesExtension) void {
        return pb_deinit(self);
    }
};

pub const TestMessageWithOneof = struct {
    pone: ?[]const u8,
    pthree: ?[]const u8,
    rone: ?TestMessageWithOneof,
    rtwo: ?[]const u8,
    normal_field: ?bool,
    repeated_field: ArrayList([]const u8),
    aone: ?i32,
    atwo: ?i32,
    bone: ?i32,
    btwo: ?i32,

    pub const _desc_table = .{
        .pone = fd(3, .String),
        .pthree = fd(5, .String),
        .rone = fd(6, .{ .SubMessage = {} }),
        .rtwo = fd(7, .String),
        .normal_field = fd(8, .{ .Varint = .Simple }),
        .repeated_field = fd(9, .{ .List = .String }),
        .aone = fd(10, .{ .Varint = .Simple }),
        .atwo = fd(11, .{ .Varint = .Simple }),
        .bone = fd(12, .{ .Varint = .Simple }),
        .btwo = fd(13, .{ .Varint = .Simple }),
    };

    pub fn encode(self: TestMessageWithOneof, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestMessageWithOneof {
        return pb_decode(TestMessageWithOneof, input, allocator);
    }
    pub fn init(allocator: Allocator) TestMessageWithOneof {
        return pb_init(TestMessageWithOneof, allocator);
    }
    pub fn deinit(self: TestMessageWithOneof) void {
        return pb_deinit(self);
    }
};

pub const TestEndsWithBytes = struct {
    value: ?i32,
    data: ?[]const u8,

    pub const _desc_table = .{
        .value = fd(1, .{ .Varint = .Simple }),
        .data = fd(2, .String),
    };

    pub fn encode(self: TestEndsWithBytes, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestEndsWithBytes {
        return pb_decode(TestEndsWithBytes, input, allocator);
    }
    pub fn init(allocator: Allocator) TestEndsWithBytes {
        return pb_init(TestEndsWithBytes, allocator);
    }
    pub fn deinit(self: TestEndsWithBytes) void {
        return pb_deinit(self);
    }
};

pub const TestMapFieldsNoBinary = struct {
    map_string_string: ArrayList(MapStringStringEntry),
    map_string_int32: ArrayList(MapStringInt32Entry),
    map_string_int64: ArrayList(MapStringInt64Entry),
    map_string_bool: ArrayList(MapStringBoolEntry),
    map_string_double: ArrayList(MapStringDoubleEntry),
    map_string_enum: ArrayList(MapStringEnumEntry),
    map_string_msg: ArrayList(MapStringMsgEntry),
    map_int32_string: ArrayList(MapInt32StringEntry),
    map_int64_string: ArrayList(MapInt64StringEntry),
    map_bool_string: ArrayList(MapBoolStringEntry),
    test_map_fields: ?TestMapFieldsNoBinary,
    map_string_testmapfields: ArrayList(MapStringTestmapfieldsEntry),

    pub const _desc_table = .{
        .map_string_string = fd(1, .{ .List = .{ .SubMessage = {} } }),
        .map_string_int32 = fd(2, .{ .List = .{ .SubMessage = {} } }),
        .map_string_int64 = fd(3, .{ .List = .{ .SubMessage = {} } }),
        .map_string_bool = fd(4, .{ .List = .{ .SubMessage = {} } }),
        .map_string_double = fd(5, .{ .List = .{ .SubMessage = {} } }),
        .map_string_enum = fd(6, .{ .List = .{ .SubMessage = {} } }),
        .map_string_msg = fd(7, .{ .List = .{ .SubMessage = {} } }),
        .map_int32_string = fd(8, .{ .List = .{ .SubMessage = {} } }),
        .map_int64_string = fd(9, .{ .List = .{ .SubMessage = {} } }),
        .map_bool_string = fd(10, .{ .List = .{ .SubMessage = {} } }),
        .test_map_fields = fd(11, .{ .SubMessage = {} }),
        .map_string_testmapfields = fd(12, .{ .List = .{ .SubMessage = {} } }),
    };

    pub const MapStringStringEntry = struct {
        key: ?[]const u8,
        value: ?[]const u8,

        pub const _desc_table = .{
            .key = fd(1, .String),
            .value = fd(2, .String),
        };

        pub fn encode(self: MapStringStringEntry, allocator: Allocator) ![]u8 {
            return pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) !MapStringStringEntry {
            return pb_decode(MapStringStringEntry, input, allocator);
        }
        pub fn init(allocator: Allocator) MapStringStringEntry {
            return pb_init(MapStringStringEntry, allocator);
        }
        pub fn deinit(self: MapStringStringEntry) void {
            return pb_deinit(self);
        }
    };

    pub const MapStringInt32Entry = struct {
        key: ?[]const u8,
        value: ?i32,

        pub const _desc_table = .{
            .key = fd(1, .String),
            .value = fd(2, .{ .Varint = .Simple }),
        };

        pub fn encode(self: MapStringInt32Entry, allocator: Allocator) ![]u8 {
            return pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) !MapStringInt32Entry {
            return pb_decode(MapStringInt32Entry, input, allocator);
        }
        pub fn init(allocator: Allocator) MapStringInt32Entry {
            return pb_init(MapStringInt32Entry, allocator);
        }
        pub fn deinit(self: MapStringInt32Entry) void {
            return pb_deinit(self);
        }
    };

    pub const MapStringInt64Entry = struct {
        key: ?[]const u8,
        value: ?i64,

        pub const _desc_table = .{
            .key = fd(1, .String),
            .value = fd(2, .{ .Varint = .Simple }),
        };

        pub fn encode(self: MapStringInt64Entry, allocator: Allocator) ![]u8 {
            return pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) !MapStringInt64Entry {
            return pb_decode(MapStringInt64Entry, input, allocator);
        }
        pub fn init(allocator: Allocator) MapStringInt64Entry {
            return pb_init(MapStringInt64Entry, allocator);
        }
        pub fn deinit(self: MapStringInt64Entry) void {
            return pb_deinit(self);
        }
    };

    pub const MapStringBoolEntry = struct {
        key: ?[]const u8,
        value: ?bool,

        pub const _desc_table = .{
            .key = fd(1, .String),
            .value = fd(2, .{ .Varint = .Simple }),
        };

        pub fn encode(self: MapStringBoolEntry, allocator: Allocator) ![]u8 {
            return pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) !MapStringBoolEntry {
            return pb_decode(MapStringBoolEntry, input, allocator);
        }
        pub fn init(allocator: Allocator) MapStringBoolEntry {
            return pb_init(MapStringBoolEntry, allocator);
        }
        pub fn deinit(self: MapStringBoolEntry) void {
            return pb_deinit(self);
        }
    };

    pub const MapStringDoubleEntry = struct {
        key: ?[]const u8,
        value: ?f64,

        pub const _desc_table = .{
            .key = fd(1, .String),
            .value = fd(2, .{ .FixedInt = .I64 }),
        };

        pub fn encode(self: MapStringDoubleEntry, allocator: Allocator) ![]u8 {
            return pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) !MapStringDoubleEntry {
            return pb_decode(MapStringDoubleEntry, input, allocator);
        }
        pub fn init(allocator: Allocator) MapStringDoubleEntry {
            return pb_init(MapStringDoubleEntry, allocator);
        }
        pub fn deinit(self: MapStringDoubleEntry) void {
            return pb_deinit(self);
        }
    };

    pub const MapStringEnumEntry = struct {
        key: ?[]const u8,
        value: ?MapValueEnumNoBinary,

        pub const _desc_table = .{
            .key = fd(1, .String),
            .value = fd(2, .{ .Varint = .Simple }),
        };

        pub fn encode(self: MapStringEnumEntry, allocator: Allocator) ![]u8 {
            return pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) !MapStringEnumEntry {
            return pb_decode(MapStringEnumEntry, input, allocator);
        }
        pub fn init(allocator: Allocator) MapStringEnumEntry {
            return pb_init(MapStringEnumEntry, allocator);
        }
        pub fn deinit(self: MapStringEnumEntry) void {
            return pb_deinit(self);
        }
    };

    pub const MapStringMsgEntry = struct {
        key: ?[]const u8,
        value: ?MapValueMessageNoBinary,

        pub const _desc_table = .{
            .key = fd(1, .String),
            .value = fd(2, .{ .SubMessage = {} }),
        };

        pub fn encode(self: MapStringMsgEntry, allocator: Allocator) ![]u8 {
            return pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) !MapStringMsgEntry {
            return pb_decode(MapStringMsgEntry, input, allocator);
        }
        pub fn init(allocator: Allocator) MapStringMsgEntry {
            return pb_init(MapStringMsgEntry, allocator);
        }
        pub fn deinit(self: MapStringMsgEntry) void {
            return pb_deinit(self);
        }
    };

    pub const MapInt32StringEntry = struct {
        key: ?i32,
        value: ?[]const u8,

        pub const _desc_table = .{
            .key = fd(1, .{ .Varint = .Simple }),
            .value = fd(2, .String),
        };

        pub fn encode(self: MapInt32StringEntry, allocator: Allocator) ![]u8 {
            return pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) !MapInt32StringEntry {
            return pb_decode(MapInt32StringEntry, input, allocator);
        }
        pub fn init(allocator: Allocator) MapInt32StringEntry {
            return pb_init(MapInt32StringEntry, allocator);
        }
        pub fn deinit(self: MapInt32StringEntry) void {
            return pb_deinit(self);
        }
    };

    pub const MapInt64StringEntry = struct {
        key: ?i64,
        value: ?[]const u8,

        pub const _desc_table = .{
            .key = fd(1, .{ .Varint = .Simple }),
            .value = fd(2, .String),
        };

        pub fn encode(self: MapInt64StringEntry, allocator: Allocator) ![]u8 {
            return pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) !MapInt64StringEntry {
            return pb_decode(MapInt64StringEntry, input, allocator);
        }
        pub fn init(allocator: Allocator) MapInt64StringEntry {
            return pb_init(MapInt64StringEntry, allocator);
        }
        pub fn deinit(self: MapInt64StringEntry) void {
            return pb_deinit(self);
        }
    };

    pub const MapBoolStringEntry = struct {
        key: ?bool,
        value: ?[]const u8,

        pub const _desc_table = .{
            .key = fd(1, .{ .Varint = .Simple }),
            .value = fd(2, .String),
        };

        pub fn encode(self: MapBoolStringEntry, allocator: Allocator) ![]u8 {
            return pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) !MapBoolStringEntry {
            return pb_decode(MapBoolStringEntry, input, allocator);
        }
        pub fn init(allocator: Allocator) MapBoolStringEntry {
            return pb_init(MapBoolStringEntry, allocator);
        }
        pub fn deinit(self: MapBoolStringEntry) void {
            return pb_deinit(self);
        }
    };

    pub const MapStringTestmapfieldsEntry = struct {
        key: ?[]const u8,
        value: ?TestMapFieldsNoBinary,

        pub const _desc_table = .{
            .key = fd(1, .String),
            .value = fd(2, .{ .SubMessage = {} }),
        };

        pub fn encode(self: MapStringTestmapfieldsEntry, allocator: Allocator) ![]u8 {
            return pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) !MapStringTestmapfieldsEntry {
            return pb_decode(MapStringTestmapfieldsEntry, input, allocator);
        }
        pub fn init(allocator: Allocator) MapStringTestmapfieldsEntry {
            return pb_init(MapStringTestmapfieldsEntry, allocator);
        }
        pub fn deinit(self: MapStringTestmapfieldsEntry) void {
            return pb_deinit(self);
        }
    };

    pub fn encode(self: TestMapFieldsNoBinary, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestMapFieldsNoBinary {
        return pb_decode(TestMapFieldsNoBinary, input, allocator);
    }
    pub fn init(allocator: Allocator) TestMapFieldsNoBinary {
        return pb_init(TestMapFieldsNoBinary, allocator);
    }
    pub fn deinit(self: TestMapFieldsNoBinary) void {
        return pb_deinit(self);
    }
};

pub const MapValueMessageNoBinary = struct {
    foo: ?i32,

    pub const _desc_table = .{
        .foo = fd(1, .{ .Varint = .Simple }),
    };

    pub fn encode(self: MapValueMessageNoBinary, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !MapValueMessageNoBinary {
        return pb_decode(MapValueMessageNoBinary, input, allocator);
    }
    pub fn init(allocator: Allocator) MapValueMessageNoBinary {
        return pb_init(MapValueMessageNoBinary, allocator);
    }
    pub fn deinit(self: MapValueMessageNoBinary) void {
        return pb_deinit(self);
    }
};

pub const Deeply = struct {
    pub const _desc_table = .{};

    pub const Nested = struct {
        pub const _desc_table = .{};

        pub const Message = struct {
            count: ?i32,

            pub const _desc_table = .{
                .count = fd(1, .{ .Varint = .Simple }),
            };

            pub fn encode(self: Message, allocator: Allocator) ![]u8 {
                return pb_encode(self, allocator);
            }
            pub fn decode(input: []const u8, allocator: Allocator) !Message {
                return pb_decode(Message, input, allocator);
            }
            pub fn init(allocator: Allocator) Message {
                return pb_init(Message, allocator);
            }
            pub fn deinit(self: Message) void {
                return pb_deinit(self);
            }
        };

        pub fn encode(self: Nested, allocator: Allocator) ![]u8 {
            return pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) !Nested {
            return pb_decode(Nested, input, allocator);
        }
        pub fn init(allocator: Allocator) Nested {
            return pb_init(Nested, allocator);
        }
        pub fn deinit(self: Nested) void {
            return pb_deinit(self);
        }
    };

    pub fn encode(self: Deeply, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !Deeply {
        return pb_decode(Deeply, input, allocator);
    }
    pub fn init(allocator: Allocator) Deeply {
        return pb_init(Deeply, allocator);
    }
    pub fn deinit(self: Deeply) void {
        return pb_deinit(self);
    }
};
