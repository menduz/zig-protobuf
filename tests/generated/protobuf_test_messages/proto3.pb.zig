// Code generated by protoc-gen-zig
 ///! package protobuf_test_messages.proto3
const std = @import("std");
const mem = std.mem;
const Allocator = mem.Allocator;
const ArrayList = std.ArrayList;

const protobuf = @import("protobuf");
const pb_decode = protobuf.pb_decode;
const pb_encode = protobuf.pb_encode;
const pb_deinit = protobuf.pb_deinit;
const pb_init = protobuf.pb_init;
const fd = protobuf.fd;
/// import package google.protobuf
const google_protobuf = @import("../google/protobuf.pb.zig");

pub const ForeignEnum = enum(i32) {
   FOREIGN_FOO = 0,
   FOREIGN_BAR = 1,
   FOREIGN_BAZ = 2,
    _,
};


pub const TestAllTypesProto3 = struct {
    optional_int32: ?i32,
    optional_int64: ?i64,
    optional_uint32: ?u32,
    optional_uint64: ?u64,
    optional_sint32: ?i32,
    optional_sint64: ?i64,
    optional_fixed32: ?u32,
    optional_fixed64: ?u64,
    optional_sfixed32: ?i32,
    optional_sfixed64: ?i64,
    optional_float: ?f32,
    optional_double: ?f64,
    optional_bool: ?bool,
    optional_string: ?[]const u8,
    optional_bytes: ?[]const u8,
    optional_nested_message: ?NestedMessage,
    optional_foreign_message: ?ForeignMessage,
    optional_nested_enum: ?NestedEnum,
    optional_foreign_enum: ?ForeignEnum,
    optional_aliased_enum: ?AliasedEnum,
    optional_string_piece: ?[]const u8,
    optional_cord: ?[]const u8,
    repeated_int32: ArrayList(i32),
    repeated_int64: ArrayList(i64),
    repeated_uint32: ArrayList(u32),
    repeated_uint64: ArrayList(u64),
    repeated_sint32: ArrayList(i32),
    repeated_sint64: ArrayList(i64),
    repeated_fixed32: ArrayList(u32),
    repeated_fixed64: ArrayList(u64),
    repeated_sfixed32: ArrayList(i32),
    repeated_sfixed64: ArrayList(i64),
    repeated_float: ArrayList(f32),
    repeated_double: ArrayList(f64),
    repeated_bool: ArrayList(bool),
    repeated_string: ArrayList([]const u8),
    repeated_bytes: ArrayList([]const u8),
    repeated_nested_message: ArrayList(NestedMessage),
    repeated_foreign_message: ArrayList(ForeignMessage),
    repeated_nested_enum: ArrayList(NestedEnum),
    repeated_foreign_enum: ArrayList(ForeignEnum),
    repeated_string_piece: ArrayList([]const u8),
    repeated_cord: ArrayList([]const u8),
    packed_int32: ArrayList(i32),
    packed_int64: ArrayList(i64),
    packed_uint32: ArrayList(u32),
    packed_uint64: ArrayList(u64),
    packed_sint32: ArrayList(i32),
    packed_sint64: ArrayList(i64),
    packed_fixed32: ArrayList(u32),
    packed_fixed64: ArrayList(u64),
    packed_sfixed32: ArrayList(i32),
    packed_sfixed64: ArrayList(i64),
    packed_float: ArrayList(f32),
    packed_double: ArrayList(f64),
    packed_bool: ArrayList(bool),
    packed_nested_enum: ArrayList(NestedEnum),
    unpacked_int32: ArrayList(i32),
    unpacked_int64: ArrayList(i64),
    unpacked_uint32: ArrayList(u32),
    unpacked_uint64: ArrayList(u64),
    unpacked_sint32: ArrayList(i32),
    unpacked_sint64: ArrayList(i64),
    unpacked_fixed32: ArrayList(u32),
    unpacked_fixed64: ArrayList(u64),
    unpacked_sfixed32: ArrayList(i32),
    unpacked_sfixed64: ArrayList(i64),
    unpacked_float: ArrayList(f32),
    unpacked_double: ArrayList(f64),
    unpacked_bool: ArrayList(bool),
    unpacked_nested_enum: ArrayList(NestedEnum),
    map_int32_int32: ArrayList(MapInt32Int32Entry),
    map_int64_int64: ArrayList(MapInt64Int64Entry),
    map_uint32_uint32: ArrayList(MapUint32Uint32Entry),
    map_uint64_uint64: ArrayList(MapUint64Uint64Entry),
    map_sint32_sint32: ArrayList(MapSint32Sint32Entry),
    map_sint64_sint64: ArrayList(MapSint64Sint64Entry),
    map_fixed32_fixed32: ArrayList(MapFixed32Fixed32Entry),
    map_fixed64_fixed64: ArrayList(MapFixed64Fixed64Entry),
    map_sfixed32_sfixed32: ArrayList(MapSfixed32Sfixed32Entry),
    map_sfixed64_sfixed64: ArrayList(MapSfixed64Sfixed64Entry),
    map_int32_float: ArrayList(MapInt32FloatEntry),
    map_int32_double: ArrayList(MapInt32DoubleEntry),
    map_bool_bool: ArrayList(MapBoolBoolEntry),
    map_string_string: ArrayList(MapStringStringEntry),
    map_string_bytes: ArrayList(MapStringBytesEntry),
    map_string_nested_message: ArrayList(MapStringNestedMessageEntry),
    map_string_foreign_message: ArrayList(MapStringForeignMessageEntry),
    map_string_nested_enum: ArrayList(MapStringNestedEnumEntry),
    map_string_foreign_enum: ArrayList(MapStringForeignEnumEntry),
    oneof_uint32: ?u32,
    oneof_nested_message: ?NestedMessage,
    oneof_string: ?[]const u8,
    oneof_bytes: ?[]const u8,
    oneof_bool: ?bool,
    oneof_uint64: ?u64,
    oneof_float: ?f32,
    oneof_double: ?f64,
    oneof_enum: ?NestedEnum,
    optional_bool_wrapper: ?google_protobuf.BoolValue,
    optional_int32_wrapper: ?google_protobuf.Int32Value,
    optional_int64_wrapper: ?google_protobuf.Int64Value,
    optional_uint32_wrapper: ?google_protobuf.UInt32Value,
    optional_uint64_wrapper: ?google_protobuf.UInt64Value,
    optional_float_wrapper: ?google_protobuf.FloatValue,
    optional_double_wrapper: ?google_protobuf.DoubleValue,
    optional_string_wrapper: ?google_protobuf.StringValue,
    optional_bytes_wrapper: ?google_protobuf.BytesValue,
    repeated_bool_wrapper: ArrayList(google_protobuf.BoolValue),
    repeated_int32_wrapper: ArrayList(google_protobuf.Int32Value),
    repeated_int64_wrapper: ArrayList(google_protobuf.Int64Value),
    repeated_uint32_wrapper: ArrayList(google_protobuf.UInt32Value),
    repeated_uint64_wrapper: ArrayList(google_protobuf.UInt64Value),
    repeated_float_wrapper: ArrayList(google_protobuf.FloatValue),
    repeated_double_wrapper: ArrayList(google_protobuf.DoubleValue),
    repeated_string_wrapper: ArrayList(google_protobuf.StringValue),
    repeated_bytes_wrapper: ArrayList(google_protobuf.BytesValue),
    optional_duration: ?google_protobuf.Duration,
    optional_timestamp: ?google_protobuf.Timestamp,
    optional_field_mask: ?google_protobuf.FieldMask,
    optional_any: ?google_protobuf.Any,
    repeated_duration: ArrayList(google_protobuf.Duration),
    repeated_timestamp: ArrayList(google_protobuf.Timestamp),
    repeated_fieldmask: ArrayList(google_protobuf.FieldMask),
    repeated_any: ArrayList(google_protobuf.Any),
    fieldname1: ?i32,
    field_name2: ?i32,
    _field_name3: ?i32,
    field__name4_: ?i32,
    field0name5: ?i32,
    field_0_name6: ?i32,
    fieldName7: ?i32,
    FieldName8: ?i32,
    field_Name9: ?i32,
    Field_Name10: ?i32,
    FIELD_NAME11: ?i32,
    FIELD_name12: ?i32,
    __field_name13: ?i32,
    __Field_name14: ?i32,
    field__name15: ?i32,
    field__Name16: ?i32,
    field_name17__: ?i32,
    Field_name18__: ?i32,

    pub const _desc_table = .{
        .optional_int32 = fd(1, .{ .Varint = .Simple }),
        .optional_int64 = fd(2, .{ .Varint = .Simple }),
        .optional_uint32 = fd(3, .{ .Varint = .Simple }),
        .optional_uint64 = fd(4, .{ .Varint = .Simple }),
        .optional_sint32 = fd(5, .{ .Varint = .ZigZagOptimized }),
        .optional_sint64 = fd(6, .{ .Varint = .ZigZagOptimized }),
        .optional_fixed32 = fd(7, .{ .FixedInt = .I32 }),
        .optional_fixed64 = fd(8, .{ .FixedInt = .I64 }),
        .optional_sfixed32 = fd(9, .{ .FixedInt = .I32 }),
        .optional_sfixed64 = fd(10, .{ .FixedInt = .I64 }),
        .optional_float = fd(11, .{ .FixedInt = .I32 }),
        .optional_double = fd(12, .{ .FixedInt = .I64 }),
        .optional_bool = fd(13, .{ .Varint = .Simple }),
        .optional_string = fd(14, .String),
        .optional_bytes = fd(15, .String),
        .optional_nested_message = fd(18, .{ .SubMessage = {} }),
        .optional_foreign_message = fd(19, .{ .SubMessage = {} }),
        .optional_nested_enum = fd(21, .{ .Varint = .Simple }),
        .optional_foreign_enum = fd(22, .{ .Varint = .Simple }),
        .optional_aliased_enum = fd(23, .{ .Varint = .Simple }),
        .optional_string_piece = fd(24, .String),
        .optional_cord = fd(25, .String),
        .repeated_int32 = fd(31, .{ .List = .{ .Varint = .Simple }}),
        .repeated_int64 = fd(32, .{ .List = .{ .Varint = .Simple }}),
        .repeated_uint32 = fd(33, .{ .List = .{ .Varint = .Simple }}),
        .repeated_uint64 = fd(34, .{ .List = .{ .Varint = .Simple }}),
        .repeated_sint32 = fd(35, .{ .List = .{ .Varint = .ZigZagOptimized }}),
        .repeated_sint64 = fd(36, .{ .List = .{ .Varint = .ZigZagOptimized }}),
        .repeated_fixed32 = fd(37, .{ .List = .{ .FixedInt = .I32 }}),
        .repeated_fixed64 = fd(38, .{ .List = .{ .FixedInt = .I64 }}),
        .repeated_sfixed32 = fd(39, .{ .List = .{ .FixedInt = .I32 }}),
        .repeated_sfixed64 = fd(40, .{ .List = .{ .FixedInt = .I64 }}),
        .repeated_float = fd(41, .{ .List = .{ .FixedInt = .I32 }}),
        .repeated_double = fd(42, .{ .List = .{ .FixedInt = .I64 }}),
        .repeated_bool = fd(43, .{ .List = .{ .Varint = .Simple }}),
        .repeated_string = fd(44, .{ .List = .String}),
        .repeated_bytes = fd(45, .{ .List = .String}),
        .repeated_nested_message = fd(48, .{ .List = .{ .SubMessage = {} }}),
        .repeated_foreign_message = fd(49, .{ .List = .{ .SubMessage = {} }}),
        .repeated_nested_enum = fd(51, .{ .List = .{ .Varint = .Simple }}),
        .repeated_foreign_enum = fd(52, .{ .List = .{ .Varint = .Simple }}),
        .repeated_string_piece = fd(54, .{ .PackedList = .String}),
        .repeated_cord = fd(55, .{ .PackedList = .String}),
        .packed_int32 = fd(75, .{ .PackedList = .{ .Varint = .Simple }}),
        .packed_int64 = fd(76, .{ .PackedList = .{ .Varint = .Simple }}),
        .packed_uint32 = fd(77, .{ .PackedList = .{ .Varint = .Simple }}),
        .packed_uint64 = fd(78, .{ .PackedList = .{ .Varint = .Simple }}),
        .packed_sint32 = fd(79, .{ .PackedList = .{ .Varint = .ZigZagOptimized }}),
        .packed_sint64 = fd(80, .{ .PackedList = .{ .Varint = .ZigZagOptimized }}),
        .packed_fixed32 = fd(81, .{ .PackedList = .{ .FixedInt = .I32 }}),
        .packed_fixed64 = fd(82, .{ .PackedList = .{ .FixedInt = .I64 }}),
        .packed_sfixed32 = fd(83, .{ .PackedList = .{ .FixedInt = .I32 }}),
        .packed_sfixed64 = fd(84, .{ .PackedList = .{ .FixedInt = .I64 }}),
        .packed_float = fd(85, .{ .PackedList = .{ .FixedInt = .I32 }}),
        .packed_double = fd(86, .{ .PackedList = .{ .FixedInt = .I64 }}),
        .packed_bool = fd(87, .{ .PackedList = .{ .Varint = .Simple }}),
        .packed_nested_enum = fd(88, .{ .PackedList = .{ .Varint = .Simple }}),
        .unpacked_int32 = fd(89, .{ .List = .{ .Varint = .Simple }}),
        .unpacked_int64 = fd(90, .{ .List = .{ .Varint = .Simple }}),
        .unpacked_uint32 = fd(91, .{ .List = .{ .Varint = .Simple }}),
        .unpacked_uint64 = fd(92, .{ .List = .{ .Varint = .Simple }}),
        .unpacked_sint32 = fd(93, .{ .List = .{ .Varint = .ZigZagOptimized }}),
        .unpacked_sint64 = fd(94, .{ .List = .{ .Varint = .ZigZagOptimized }}),
        .unpacked_fixed32 = fd(95, .{ .List = .{ .FixedInt = .I32 }}),
        .unpacked_fixed64 = fd(96, .{ .List = .{ .FixedInt = .I64 }}),
        .unpacked_sfixed32 = fd(97, .{ .List = .{ .FixedInt = .I32 }}),
        .unpacked_sfixed64 = fd(98, .{ .List = .{ .FixedInt = .I64 }}),
        .unpacked_float = fd(99, .{ .List = .{ .FixedInt = .I32 }}),
        .unpacked_double = fd(100, .{ .List = .{ .FixedInt = .I64 }}),
        .unpacked_bool = fd(101, .{ .List = .{ .Varint = .Simple }}),
        .unpacked_nested_enum = fd(102, .{ .List = .{ .Varint = .Simple }}),
        .map_int32_int32 = fd(56, .{ .List = .{ .SubMessage = {} }}),
        .map_int64_int64 = fd(57, .{ .List = .{ .SubMessage = {} }}),
        .map_uint32_uint32 = fd(58, .{ .List = .{ .SubMessage = {} }}),
        .map_uint64_uint64 = fd(59, .{ .List = .{ .SubMessage = {} }}),
        .map_sint32_sint32 = fd(60, .{ .List = .{ .SubMessage = {} }}),
        .map_sint64_sint64 = fd(61, .{ .List = .{ .SubMessage = {} }}),
        .map_fixed32_fixed32 = fd(62, .{ .List = .{ .SubMessage = {} }}),
        .map_fixed64_fixed64 = fd(63, .{ .List = .{ .SubMessage = {} }}),
        .map_sfixed32_sfixed32 = fd(64, .{ .List = .{ .SubMessage = {} }}),
        .map_sfixed64_sfixed64 = fd(65, .{ .List = .{ .SubMessage = {} }}),
        .map_int32_float = fd(66, .{ .List = .{ .SubMessage = {} }}),
        .map_int32_double = fd(67, .{ .List = .{ .SubMessage = {} }}),
        .map_bool_bool = fd(68, .{ .List = .{ .SubMessage = {} }}),
        .map_string_string = fd(69, .{ .List = .{ .SubMessage = {} }}),
        .map_string_bytes = fd(70, .{ .List = .{ .SubMessage = {} }}),
        .map_string_nested_message = fd(71, .{ .List = .{ .SubMessage = {} }}),
        .map_string_foreign_message = fd(72, .{ .List = .{ .SubMessage = {} }}),
        .map_string_nested_enum = fd(73, .{ .List = .{ .SubMessage = {} }}),
        .map_string_foreign_enum = fd(74, .{ .List = .{ .SubMessage = {} }}),
        .oneof_uint32 = fd(111, .{ .Varint = .Simple }),
        .oneof_nested_message = fd(112, .{ .SubMessage = {} }),
        .oneof_string = fd(113, .String),
        .oneof_bytes = fd(114, .String),
        .oneof_bool = fd(115, .{ .Varint = .Simple }),
        .oneof_uint64 = fd(116, .{ .Varint = .Simple }),
        .oneof_float = fd(117, .{ .FixedInt = .I32 }),
        .oneof_double = fd(118, .{ .FixedInt = .I64 }),
        .oneof_enum = fd(119, .{ .Varint = .Simple }),
        .optional_bool_wrapper = fd(201, .{ .SubMessage = {} }),
        .optional_int32_wrapper = fd(202, .{ .SubMessage = {} }),
        .optional_int64_wrapper = fd(203, .{ .SubMessage = {} }),
        .optional_uint32_wrapper = fd(204, .{ .SubMessage = {} }),
        .optional_uint64_wrapper = fd(205, .{ .SubMessage = {} }),
        .optional_float_wrapper = fd(206, .{ .SubMessage = {} }),
        .optional_double_wrapper = fd(207, .{ .SubMessage = {} }),
        .optional_string_wrapper = fd(208, .{ .SubMessage = {} }),
        .optional_bytes_wrapper = fd(209, .{ .SubMessage = {} }),
        .repeated_bool_wrapper = fd(211, .{ .List = .{ .SubMessage = {} }}),
        .repeated_int32_wrapper = fd(212, .{ .List = .{ .SubMessage = {} }}),
        .repeated_int64_wrapper = fd(213, .{ .List = .{ .SubMessage = {} }}),
        .repeated_uint32_wrapper = fd(214, .{ .List = .{ .SubMessage = {} }}),
        .repeated_uint64_wrapper = fd(215, .{ .List = .{ .SubMessage = {} }}),
        .repeated_float_wrapper = fd(216, .{ .List = .{ .SubMessage = {} }}),
        .repeated_double_wrapper = fd(217, .{ .List = .{ .SubMessage = {} }}),
        .repeated_string_wrapper = fd(218, .{ .List = .{ .SubMessage = {} }}),
        .repeated_bytes_wrapper = fd(219, .{ .List = .{ .SubMessage = {} }}),
        .optional_duration = fd(301, .{ .SubMessage = {} }),
        .optional_timestamp = fd(302, .{ .SubMessage = {} }),
        .optional_field_mask = fd(303, .{ .SubMessage = {} }),
        .optional_any = fd(305, .{ .SubMessage = {} }),
        .repeated_duration = fd(311, .{ .List = .{ .SubMessage = {} }}),
        .repeated_timestamp = fd(312, .{ .List = .{ .SubMessage = {} }}),
        .repeated_fieldmask = fd(313, .{ .List = .{ .SubMessage = {} }}),
        .repeated_any = fd(315, .{ .List = .{ .SubMessage = {} }}),
        .fieldname1 = fd(401, .{ .Varint = .Simple }),
        .field_name2 = fd(402, .{ .Varint = .Simple }),
        ._field_name3 = fd(403, .{ .Varint = .Simple }),
        .field__name4_ = fd(404, .{ .Varint = .Simple }),
        .field0name5 = fd(405, .{ .Varint = .Simple }),
        .field_0_name6 = fd(406, .{ .Varint = .Simple }),
        .fieldName7 = fd(407, .{ .Varint = .Simple }),
        .FieldName8 = fd(408, .{ .Varint = .Simple }),
        .field_Name9 = fd(409, .{ .Varint = .Simple }),
        .Field_Name10 = fd(410, .{ .Varint = .Simple }),
        .FIELD_NAME11 = fd(411, .{ .Varint = .Simple }),
        .FIELD_name12 = fd(412, .{ .Varint = .Simple }),
        .__field_name13 = fd(413, .{ .Varint = .Simple }),
        .__Field_name14 = fd(414, .{ .Varint = .Simple }),
        .field__name15 = fd(415, .{ .Varint = .Simple }),
        .field__Name16 = fd(416, .{ .Varint = .Simple }),
        .field_name17__ = fd(417, .{ .Varint = .Simple }),
        .Field_name18__ = fd(418, .{ .Varint = .Simple }),
    };

pub const NestedEnum = enum(i32) {
   FOO = 0,
   BAR = 1,
   BAZ = 2,
   NEG = -1,
    _,
};


pub const AliasedEnum = enum(i32) {
   ALIAS_FOO = 0,
   ALIAS_BAR = 1,
   MOO = 2,
    _,
};


pub const NestedMessage = struct {
    a: ?i32,

    pub const _desc_table = .{
        .a = fd(1, .{ .Varint = .Simple }),
    };


    pub fn encode(self: NestedMessage, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !NestedMessage {
        return pb_decode(NestedMessage, input, allocator);
    }
    pub fn init(allocator: Allocator) NestedMessage {
        return pb_init(NestedMessage, allocator);
    }
    pub fn deinit(self: NestedMessage) void {
        return pb_deinit(self);
    }
};

pub const MapInt32Int32Entry = struct {
    key: ?i32,
    value: ?i32,

    pub const _desc_table = .{
        .key = fd(1, .{ .Varint = .Simple }),
        .value = fd(2, .{ .Varint = .Simple }),
    };


    pub fn encode(self: MapInt32Int32Entry, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !MapInt32Int32Entry {
        return pb_decode(MapInt32Int32Entry, input, allocator);
    }
    pub fn init(allocator: Allocator) MapInt32Int32Entry {
        return pb_init(MapInt32Int32Entry, allocator);
    }
    pub fn deinit(self: MapInt32Int32Entry) void {
        return pb_deinit(self);
    }
};

pub const MapInt64Int64Entry = struct {
    key: ?i64,
    value: ?i64,

    pub const _desc_table = .{
        .key = fd(1, .{ .Varint = .Simple }),
        .value = fd(2, .{ .Varint = .Simple }),
    };


    pub fn encode(self: MapInt64Int64Entry, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !MapInt64Int64Entry {
        return pb_decode(MapInt64Int64Entry, input, allocator);
    }
    pub fn init(allocator: Allocator) MapInt64Int64Entry {
        return pb_init(MapInt64Int64Entry, allocator);
    }
    pub fn deinit(self: MapInt64Int64Entry) void {
        return pb_deinit(self);
    }
};

pub const MapUint32Uint32Entry = struct {
    key: ?u32,
    value: ?u32,

    pub const _desc_table = .{
        .key = fd(1, .{ .Varint = .Simple }),
        .value = fd(2, .{ .Varint = .Simple }),
    };


    pub fn encode(self: MapUint32Uint32Entry, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !MapUint32Uint32Entry {
        return pb_decode(MapUint32Uint32Entry, input, allocator);
    }
    pub fn init(allocator: Allocator) MapUint32Uint32Entry {
        return pb_init(MapUint32Uint32Entry, allocator);
    }
    pub fn deinit(self: MapUint32Uint32Entry) void {
        return pb_deinit(self);
    }
};

pub const MapUint64Uint64Entry = struct {
    key: ?u64,
    value: ?u64,

    pub const _desc_table = .{
        .key = fd(1, .{ .Varint = .Simple }),
        .value = fd(2, .{ .Varint = .Simple }),
    };


    pub fn encode(self: MapUint64Uint64Entry, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !MapUint64Uint64Entry {
        return pb_decode(MapUint64Uint64Entry, input, allocator);
    }
    pub fn init(allocator: Allocator) MapUint64Uint64Entry {
        return pb_init(MapUint64Uint64Entry, allocator);
    }
    pub fn deinit(self: MapUint64Uint64Entry) void {
        return pb_deinit(self);
    }
};

pub const MapSint32Sint32Entry = struct {
    key: ?i32,
    value: ?i32,

    pub const _desc_table = .{
        .key = fd(1, .{ .Varint = .ZigZagOptimized }),
        .value = fd(2, .{ .Varint = .ZigZagOptimized }),
    };


    pub fn encode(self: MapSint32Sint32Entry, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !MapSint32Sint32Entry {
        return pb_decode(MapSint32Sint32Entry, input, allocator);
    }
    pub fn init(allocator: Allocator) MapSint32Sint32Entry {
        return pb_init(MapSint32Sint32Entry, allocator);
    }
    pub fn deinit(self: MapSint32Sint32Entry) void {
        return pb_deinit(self);
    }
};

pub const MapSint64Sint64Entry = struct {
    key: ?i64,
    value: ?i64,

    pub const _desc_table = .{
        .key = fd(1, .{ .Varint = .ZigZagOptimized }),
        .value = fd(2, .{ .Varint = .ZigZagOptimized }),
    };


    pub fn encode(self: MapSint64Sint64Entry, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !MapSint64Sint64Entry {
        return pb_decode(MapSint64Sint64Entry, input, allocator);
    }
    pub fn init(allocator: Allocator) MapSint64Sint64Entry {
        return pb_init(MapSint64Sint64Entry, allocator);
    }
    pub fn deinit(self: MapSint64Sint64Entry) void {
        return pb_deinit(self);
    }
};

pub const MapFixed32Fixed32Entry = struct {
    key: ?u32,
    value: ?u32,

    pub const _desc_table = .{
        .key = fd(1, .{ .FixedInt = .I32 }),
        .value = fd(2, .{ .FixedInt = .I32 }),
    };


    pub fn encode(self: MapFixed32Fixed32Entry, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !MapFixed32Fixed32Entry {
        return pb_decode(MapFixed32Fixed32Entry, input, allocator);
    }
    pub fn init(allocator: Allocator) MapFixed32Fixed32Entry {
        return pb_init(MapFixed32Fixed32Entry, allocator);
    }
    pub fn deinit(self: MapFixed32Fixed32Entry) void {
        return pb_deinit(self);
    }
};

pub const MapFixed64Fixed64Entry = struct {
    key: ?u64,
    value: ?u64,

    pub const _desc_table = .{
        .key = fd(1, .{ .FixedInt = .I64 }),
        .value = fd(2, .{ .FixedInt = .I64 }),
    };


    pub fn encode(self: MapFixed64Fixed64Entry, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !MapFixed64Fixed64Entry {
        return pb_decode(MapFixed64Fixed64Entry, input, allocator);
    }
    pub fn init(allocator: Allocator) MapFixed64Fixed64Entry {
        return pb_init(MapFixed64Fixed64Entry, allocator);
    }
    pub fn deinit(self: MapFixed64Fixed64Entry) void {
        return pb_deinit(self);
    }
};

pub const MapSfixed32Sfixed32Entry = struct {
    key: ?i32,
    value: ?i32,

    pub const _desc_table = .{
        .key = fd(1, .{ .FixedInt = .I32 }),
        .value = fd(2, .{ .FixedInt = .I32 }),
    };


    pub fn encode(self: MapSfixed32Sfixed32Entry, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !MapSfixed32Sfixed32Entry {
        return pb_decode(MapSfixed32Sfixed32Entry, input, allocator);
    }
    pub fn init(allocator: Allocator) MapSfixed32Sfixed32Entry {
        return pb_init(MapSfixed32Sfixed32Entry, allocator);
    }
    pub fn deinit(self: MapSfixed32Sfixed32Entry) void {
        return pb_deinit(self);
    }
};

pub const MapSfixed64Sfixed64Entry = struct {
    key: ?i64,
    value: ?i64,

    pub const _desc_table = .{
        .key = fd(1, .{ .FixedInt = .I64 }),
        .value = fd(2, .{ .FixedInt = .I64 }),
    };


    pub fn encode(self: MapSfixed64Sfixed64Entry, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !MapSfixed64Sfixed64Entry {
        return pb_decode(MapSfixed64Sfixed64Entry, input, allocator);
    }
    pub fn init(allocator: Allocator) MapSfixed64Sfixed64Entry {
        return pb_init(MapSfixed64Sfixed64Entry, allocator);
    }
    pub fn deinit(self: MapSfixed64Sfixed64Entry) void {
        return pb_deinit(self);
    }
};

pub const MapInt32FloatEntry = struct {
    key: ?i32,
    value: ?f32,

    pub const _desc_table = .{
        .key = fd(1, .{ .Varint = .Simple }),
        .value = fd(2, .{ .FixedInt = .I32 }),
    };


    pub fn encode(self: MapInt32FloatEntry, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !MapInt32FloatEntry {
        return pb_decode(MapInt32FloatEntry, input, allocator);
    }
    pub fn init(allocator: Allocator) MapInt32FloatEntry {
        return pb_init(MapInt32FloatEntry, allocator);
    }
    pub fn deinit(self: MapInt32FloatEntry) void {
        return pb_deinit(self);
    }
};

pub const MapInt32DoubleEntry = struct {
    key: ?i32,
    value: ?f64,

    pub const _desc_table = .{
        .key = fd(1, .{ .Varint = .Simple }),
        .value = fd(2, .{ .FixedInt = .I64 }),
    };


    pub fn encode(self: MapInt32DoubleEntry, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !MapInt32DoubleEntry {
        return pb_decode(MapInt32DoubleEntry, input, allocator);
    }
    pub fn init(allocator: Allocator) MapInt32DoubleEntry {
        return pb_init(MapInt32DoubleEntry, allocator);
    }
    pub fn deinit(self: MapInt32DoubleEntry) void {
        return pb_deinit(self);
    }
};

pub const MapBoolBoolEntry = struct {
    key: ?bool,
    value: ?bool,

    pub const _desc_table = .{
        .key = fd(1, .{ .Varint = .Simple }),
        .value = fd(2, .{ .Varint = .Simple }),
    };


    pub fn encode(self: MapBoolBoolEntry, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !MapBoolBoolEntry {
        return pb_decode(MapBoolBoolEntry, input, allocator);
    }
    pub fn init(allocator: Allocator) MapBoolBoolEntry {
        return pb_init(MapBoolBoolEntry, allocator);
    }
    pub fn deinit(self: MapBoolBoolEntry) void {
        return pb_deinit(self);
    }
};

pub const MapStringStringEntry = struct {
    key: ?[]const u8,
    value: ?[]const u8,

    pub const _desc_table = .{
        .key = fd(1, .String),
        .value = fd(2, .String),
    };


    pub fn encode(self: MapStringStringEntry, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !MapStringStringEntry {
        return pb_decode(MapStringStringEntry, input, allocator);
    }
    pub fn init(allocator: Allocator) MapStringStringEntry {
        return pb_init(MapStringStringEntry, allocator);
    }
    pub fn deinit(self: MapStringStringEntry) void {
        return pb_deinit(self);
    }
};

pub const MapStringBytesEntry = struct {
    key: ?[]const u8,
    value: ?[]const u8,

    pub const _desc_table = .{
        .key = fd(1, .String),
        .value = fd(2, .String),
    };


    pub fn encode(self: MapStringBytesEntry, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !MapStringBytesEntry {
        return pb_decode(MapStringBytesEntry, input, allocator);
    }
    pub fn init(allocator: Allocator) MapStringBytesEntry {
        return pb_init(MapStringBytesEntry, allocator);
    }
    pub fn deinit(self: MapStringBytesEntry) void {
        return pb_deinit(self);
    }
};

pub const MapStringNestedMessageEntry = struct {
    key: ?[]const u8,
    value: ?TestAllTypesProto3.NestedMessage,

    pub const _desc_table = .{
        .key = fd(1, .String),
        .value = fd(2, .{ .SubMessage = {} }),
    };


    pub fn encode(self: MapStringNestedMessageEntry, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !MapStringNestedMessageEntry {
        return pb_decode(MapStringNestedMessageEntry, input, allocator);
    }
    pub fn init(allocator: Allocator) MapStringNestedMessageEntry {
        return pb_init(MapStringNestedMessageEntry, allocator);
    }
    pub fn deinit(self: MapStringNestedMessageEntry) void {
        return pb_deinit(self);
    }
};

pub const MapStringForeignMessageEntry = struct {
    key: ?[]const u8,
    value: ?ForeignMessage,

    pub const _desc_table = .{
        .key = fd(1, .String),
        .value = fd(2, .{ .SubMessage = {} }),
    };


    pub fn encode(self: MapStringForeignMessageEntry, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !MapStringForeignMessageEntry {
        return pb_decode(MapStringForeignMessageEntry, input, allocator);
    }
    pub fn init(allocator: Allocator) MapStringForeignMessageEntry {
        return pb_init(MapStringForeignMessageEntry, allocator);
    }
    pub fn deinit(self: MapStringForeignMessageEntry) void {
        return pb_deinit(self);
    }
};

pub const MapStringNestedEnumEntry = struct {
    key: ?[]const u8,
    value: ?TestAllTypesProto3.NestedEnum,

    pub const _desc_table = .{
        .key = fd(1, .String),
        .value = fd(2, .{ .Varint = .Simple }),
    };


    pub fn encode(self: MapStringNestedEnumEntry, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !MapStringNestedEnumEntry {
        return pb_decode(MapStringNestedEnumEntry, input, allocator);
    }
    pub fn init(allocator: Allocator) MapStringNestedEnumEntry {
        return pb_init(MapStringNestedEnumEntry, allocator);
    }
    pub fn deinit(self: MapStringNestedEnumEntry) void {
        return pb_deinit(self);
    }
};

pub const MapStringForeignEnumEntry = struct {
    key: ?[]const u8,
    value: ?ForeignEnum,

    pub const _desc_table = .{
        .key = fd(1, .String),
        .value = fd(2, .{ .Varint = .Simple }),
    };


    pub fn encode(self: MapStringForeignEnumEntry, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !MapStringForeignEnumEntry {
        return pb_decode(MapStringForeignEnumEntry, input, allocator);
    }
    pub fn init(allocator: Allocator) MapStringForeignEnumEntry {
        return pb_init(MapStringForeignEnumEntry, allocator);
    }
    pub fn deinit(self: MapStringForeignEnumEntry) void {
        return pb_deinit(self);
    }
};


    pub fn encode(self: TestAllTypesProto3, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestAllTypesProto3 {
        return pb_decode(TestAllTypesProto3, input, allocator);
    }
    pub fn init(allocator: Allocator) TestAllTypesProto3 {
        return pb_init(TestAllTypesProto3, allocator);
    }
    pub fn deinit(self: TestAllTypesProto3) void {
        return pb_deinit(self);
    }
};

pub const ForeignMessage = struct {
    c: ?i32,

    pub const _desc_table = .{
        .c = fd(1, .{ .Varint = .Simple }),
    };


    pub fn encode(self: ForeignMessage, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !ForeignMessage {
        return pb_decode(ForeignMessage, input, allocator);
    }
    pub fn init(allocator: Allocator) ForeignMessage {
        return pb_init(ForeignMessage, allocator);
    }
    pub fn deinit(self: ForeignMessage) void {
        return pb_deinit(self);
    }
};

pub const NullHypothesisProto3 = struct {

    pub const _desc_table = .{
    };


    pub fn encode(self: NullHypothesisProto3, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !NullHypothesisProto3 {
        return pb_decode(NullHypothesisProto3, input, allocator);
    }
    pub fn init(allocator: Allocator) NullHypothesisProto3 {
        return pb_init(NullHypothesisProto3, allocator);
    }
    pub fn deinit(self: NullHypothesisProto3) void {
        return pb_deinit(self);
    }
};

pub const EnumOnlyProto3 = struct {

    pub const _desc_table = .{
    };

pub const Bool = enum(i32) {
   kFalse = 0,
   kTrue = 1,
    _,
};



    pub fn encode(self: EnumOnlyProto3, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !EnumOnlyProto3 {
        return pb_decode(EnumOnlyProto3, input, allocator);
    }
    pub fn init(allocator: Allocator) EnumOnlyProto3 {
        return pb_init(EnumOnlyProto3, allocator);
    }
    pub fn deinit(self: EnumOnlyProto3) void {
        return pb_deinit(self);
    }
};
