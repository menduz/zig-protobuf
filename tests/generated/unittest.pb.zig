// Code generated by protoc-gen-zig
 ///! package unittest
const std = @import("std");
const mem = std.mem;
const Allocator = mem.Allocator;
const ArrayList = std.ArrayList;

const protobuf = @import("protobuf");
const pb_decode = protobuf.pb_decode;
const pb_encode = protobuf.pb_encode;
const pb_deinit = protobuf.pb_deinit;
const pb_init = protobuf.pb_init;
const fd = protobuf.fd;

pub const ForeignEnum = enum(i32) {
   FOREIGN_FOO = 4,
   FOREIGN_BAR = 5,
   FOREIGN_BAZ = 6,
    _,
};


pub const TestReservedEnumFields = enum(i32) {
   UNKNOWN = 0,
    _,
};


pub const TestEnumWithDupValue = enum(i32) {
   FOO1 = 1,
   BAR1 = 2,
   BAZ = 3,
   FOO2 = 1,
   BAR2 = 2,
    _,
};


pub const TestSparseEnum = enum(i32) {
   SPARSE_A = 123,
   SPARSE_B = 62374,
   SPARSE_C = 12589234,
   SPARSE_D = -15,
   SPARSE_E = -53452,
   SPARSE_F = 0,
   SPARSE_G = 2,
    _,
};


pub const VeryLargeEnum = enum(i32) {
   ENUM_LABEL_DEFAULT = 0,
   ENUM_LABEL_1 = 1,
   ENUM_LABEL_2 = 2,
   ENUM_LABEL_3 = 3,
   ENUM_LABEL_4 = 4,
   ENUM_LABEL_5 = 5,
   ENUM_LABEL_6 = 6,
   ENUM_LABEL_7 = 7,
   ENUM_LABEL_8 = 8,
   ENUM_LABEL_9 = 9,
   ENUM_LABEL_10 = 10,
   ENUM_LABEL_11 = 11,
   ENUM_LABEL_12 = 12,
   ENUM_LABEL_13 = 13,
   ENUM_LABEL_14 = 14,
   ENUM_LABEL_15 = 15,
   ENUM_LABEL_16 = 16,
   ENUM_LABEL_17 = 17,
   ENUM_LABEL_18 = 18,
   ENUM_LABEL_19 = 19,
   ENUM_LABEL_20 = 20,
   ENUM_LABEL_21 = 21,
   ENUM_LABEL_22 = 22,
   ENUM_LABEL_23 = 23,
   ENUM_LABEL_24 = 24,
   ENUM_LABEL_25 = 25,
   ENUM_LABEL_26 = 26,
   ENUM_LABEL_27 = 27,
   ENUM_LABEL_28 = 28,
   ENUM_LABEL_29 = 29,
   ENUM_LABEL_30 = 30,
   ENUM_LABEL_31 = 31,
   ENUM_LABEL_32 = 32,
   ENUM_LABEL_33 = 33,
   ENUM_LABEL_34 = 34,
   ENUM_LABEL_35 = 35,
   ENUM_LABEL_36 = 36,
   ENUM_LABEL_37 = 37,
   ENUM_LABEL_38 = 38,
   ENUM_LABEL_39 = 39,
   ENUM_LABEL_40 = 40,
   ENUM_LABEL_41 = 41,
   ENUM_LABEL_42 = 42,
   ENUM_LABEL_43 = 43,
   ENUM_LABEL_44 = 44,
   ENUM_LABEL_45 = 45,
   ENUM_LABEL_46 = 46,
   ENUM_LABEL_47 = 47,
   ENUM_LABEL_48 = 48,
   ENUM_LABEL_49 = 49,
   ENUM_LABEL_50 = 50,
   ENUM_LABEL_51 = 51,
   ENUM_LABEL_52 = 52,
   ENUM_LABEL_53 = 53,
   ENUM_LABEL_54 = 54,
   ENUM_LABEL_55 = 55,
   ENUM_LABEL_56 = 56,
   ENUM_LABEL_57 = 57,
   ENUM_LABEL_58 = 58,
   ENUM_LABEL_59 = 59,
   ENUM_LABEL_60 = 60,
   ENUM_LABEL_61 = 61,
   ENUM_LABEL_62 = 62,
   ENUM_LABEL_63 = 63,
   ENUM_LABEL_64 = 64,
   ENUM_LABEL_65 = 65,
   ENUM_LABEL_66 = 66,
   ENUM_LABEL_67 = 67,
   ENUM_LABEL_68 = 68,
   ENUM_LABEL_69 = 69,
   ENUM_LABEL_70 = 70,
   ENUM_LABEL_71 = 71,
   ENUM_LABEL_72 = 72,
   ENUM_LABEL_73 = 73,
   ENUM_LABEL_74 = 74,
   ENUM_LABEL_75 = 75,
   ENUM_LABEL_76 = 76,
   ENUM_LABEL_77 = 77,
   ENUM_LABEL_78 = 78,
   ENUM_LABEL_79 = 79,
   ENUM_LABEL_80 = 80,
   ENUM_LABEL_81 = 81,
   ENUM_LABEL_82 = 82,
   ENUM_LABEL_83 = 83,
   ENUM_LABEL_84 = 84,
   ENUM_LABEL_85 = 85,
   ENUM_LABEL_86 = 86,
   ENUM_LABEL_87 = 87,
   ENUM_LABEL_88 = 88,
   ENUM_LABEL_89 = 89,
   ENUM_LABEL_90 = 90,
   ENUM_LABEL_91 = 91,
   ENUM_LABEL_92 = 92,
   ENUM_LABEL_93 = 93,
   ENUM_LABEL_94 = 94,
   ENUM_LABEL_95 = 95,
   ENUM_LABEL_96 = 96,
   ENUM_LABEL_97 = 97,
   ENUM_LABEL_98 = 98,
   ENUM_LABEL_99 = 99,
   ENUM_LABEL_100 = 100,
    _,
};


pub const TestAllTypes = struct {
    optional_int32: ?i32,
    optional_int64: ?i64,
    optional_uint32: ?u32,
    optional_uint64: ?u64,
    optional_sint32: ?i32,
    optional_sint64: ?i64,
    optional_fixed32: ?u32,
    optional_fixed64: ?u64,
    optional_sfixed32: ?i32,
    optional_sfixed64: ?i64,
    optional_float: ?f32,
    optional_double: ?f64,
    optional_bool: ?bool,
    optional_string: ?[]const u8,
    optional_bytes: ?[]const u8,
    a: ?i32,
    optional_nested_message: ?NestedMessage,
    optional_foreign_message: ?ForeignMessage,
    optional_nested_enum: ?NestedEnum,
    optional_foreign_enum: ?ForeignEnum,
    optional_string_piece: ?[]const u8,
    optional_cord: ?[]const u8,
    optional_lazy_message: ?NestedMessage,
    repeated_int32: ArrayList(i32),
    repeated_int64: ArrayList(i64),
    repeated_uint32: ArrayList(u32),
    repeated_uint64: ArrayList(u64),
    repeated_sint32: ArrayList(i32),
    repeated_sint64: ArrayList(i64),
    repeated_fixed32: ArrayList(u32),
    repeated_fixed64: ArrayList(u64),
    repeated_sfixed32: ArrayList(i32),
    repeated_sfixed64: ArrayList(i64),
    repeated_float: ArrayList(f32),
    repeated_double: ArrayList(f64),
    repeated_bool: ArrayList(bool),
    repeated_string: ArrayList([]const u8),
    repeated_bytes: ArrayList([]const u8),
    RepeatedGroup_a: ArrayList(i32),
    repeated_nested_message: ArrayList(NestedMessage),
    repeated_foreign_message: ArrayList(ForeignMessage),
    repeated_nested_enum: ArrayList(NestedEnum),
    repeated_foreign_enum: ArrayList(ForeignEnum),
    repeated_string_piece: ArrayList([]const u8),
    repeated_cord: ArrayList([]const u8),
    repeated_lazy_message: ArrayList(NestedMessage),
    default_int32: ?i32,
    default_int64: ?i64,
    default_uint32: ?u32,
    default_uint64: ?u64,
    default_sint32: ?i32,
    default_sint64: ?i64,
    default_fixed32: ?u32,
    default_fixed64: ?u64,
    default_sfixed32: ?i32,
    default_sfixed64: ?i64,
    default_float: ?f32,
    default_double: ?f64,
    default_bool: ?bool,
    default_string: ?[]const u8,
    default_bytes: ?[]const u8,
    default_nested_enum: ?NestedEnum,
    default_foreign_enum: ?ForeignEnum,
    default_string_piece: ?[]const u8,
    default_cord: ?[]const u8,
    oneof_uint32: ?u32,
    oneof_nested_message: ?NestedMessage,
    oneof_string: ?[]const u8,
    oneof_bytes: ?[]const u8,

    pub const _desc_table = .{
        .optional_int32 = fd(1, .{ .Varint = .Simple }),
        .optional_int64 = fd(2, .{ .Varint = .Simple }),
        .optional_uint32 = fd(3, .{ .Varint = .Simple }),
        .optional_uint64 = fd(4, .{ .Varint = .Simple }),
        .optional_sint32 = fd(5, .{ .Varint = .ZigZagOptimized }),
        .optional_sint64 = fd(6, .{ .Varint = .ZigZagOptimized }),
        .optional_fixed32 = fd(7, .{ .FixedInt = .I32 }),
        .optional_fixed64 = fd(8, .{ .FixedInt = .I64 }),
        .optional_sfixed32 = fd(9, .{ .FixedInt = .I32 }),
        .optional_sfixed64 = fd(10, .{ .FixedInt = .I64 }),
        .optional_float = fd(11, .{ .FixedInt = .I32 }),
        .optional_double = fd(12, .{ .FixedInt = .I64 }),
        .optional_bool = fd(13, .{ .Varint = .Simple }),
        .optional_string = fd(14, .String),
        .optional_bytes = fd(15, .String),
        .a = fd(17, .{ .Varint = .Simple }),
        .optional_nested_message = fd(18, .{ .SubMessage = {} }),
        .optional_foreign_message = fd(19, .{ .SubMessage = {} }),
        .optional_nested_enum = fd(21, .{ .Varint = .Simple }),
        .optional_foreign_enum = fd(22, .{ .Varint = .Simple }),
        .optional_string_piece = fd(24, .String),
        .optional_cord = fd(25, .String),
        .optional_lazy_message = fd(27, .{ .SubMessage = {} }),
        .repeated_int32 = fd(31, .{ .List = .{ .Varint = .Simple }}),
        .repeated_int64 = fd(32, .{ .List = .{ .Varint = .Simple }}),
        .repeated_uint32 = fd(33, .{ .List = .{ .Varint = .Simple }}),
        .repeated_uint64 = fd(34, .{ .List = .{ .Varint = .Simple }}),
        .repeated_sint32 = fd(35, .{ .List = .{ .Varint = .ZigZagOptimized }}),
        .repeated_sint64 = fd(36, .{ .List = .{ .Varint = .ZigZagOptimized }}),
        .repeated_fixed32 = fd(37, .{ .List = .{ .FixedInt = .I32 }}),
        .repeated_fixed64 = fd(38, .{ .List = .{ .FixedInt = .I64 }}),
        .repeated_sfixed32 = fd(39, .{ .List = .{ .FixedInt = .I32 }}),
        .repeated_sfixed64 = fd(40, .{ .List = .{ .FixedInt = .I64 }}),
        .repeated_float = fd(41, .{ .List = .{ .FixedInt = .I32 }}),
        .repeated_double = fd(42, .{ .List = .{ .FixedInt = .I64 }}),
        .repeated_bool = fd(43, .{ .List = .{ .Varint = .Simple }}),
        .repeated_string = fd(44, .{ .List = .String}),
        .repeated_bytes = fd(45, .{ .List = .String}),
        .RepeatedGroup_a = fd(47, .{ .List = .{ .Varint = .Simple }}),
        .repeated_nested_message = fd(48, .{ .List = .{ .SubMessage = {} }}),
        .repeated_foreign_message = fd(49, .{ .List = .{ .SubMessage = {} }}),
        .repeated_nested_enum = fd(51, .{ .List = .{ .Varint = .Simple }}),
        .repeated_foreign_enum = fd(52, .{ .List = .{ .Varint = .Simple }}),
        .repeated_string_piece = fd(54, .{ .List = .String}),
        .repeated_cord = fd(55, .{ .List = .String}),
        .repeated_lazy_message = fd(57, .{ .List = .{ .SubMessage = {} }}),
        .default_int32 = fd(61, .{ .Varint = .Simple }),
        .default_int64 = fd(62, .{ .Varint = .Simple }),
        .default_uint32 = fd(63, .{ .Varint = .Simple }),
        .default_uint64 = fd(64, .{ .Varint = .Simple }),
        .default_sint32 = fd(65, .{ .Varint = .ZigZagOptimized }),
        .default_sint64 = fd(66, .{ .Varint = .ZigZagOptimized }),
        .default_fixed32 = fd(67, .{ .FixedInt = .I32 }),
        .default_fixed64 = fd(68, .{ .FixedInt = .I64 }),
        .default_sfixed32 = fd(69, .{ .FixedInt = .I32 }),
        .default_sfixed64 = fd(70, .{ .FixedInt = .I64 }),
        .default_float = fd(71, .{ .FixedInt = .I32 }),
        .default_double = fd(72, .{ .FixedInt = .I64 }),
        .default_bool = fd(73, .{ .Varint = .Simple }),
        .default_string = fd(74, .String),
        .default_bytes = fd(75, .String),
        .default_nested_enum = fd(81, .{ .Varint = .Simple }),
        .default_foreign_enum = fd(82, .{ .Varint = .Simple }),
        .default_string_piece = fd(84, .String),
        .default_cord = fd(85, .String),
        .oneof_uint32 = fd(111, .{ .Varint = .Simple }),
        .oneof_nested_message = fd(112, .{ .SubMessage = {} }),
        .oneof_string = fd(113, .String),
        .oneof_bytes = fd(114, .String),
    };

pub const NestedEnum = enum(i32) {
   FOO = 1,
   BAR = 2,
   BAZ = 3,
   NEG = -1,
    _,
};


pub const NestedMessage = struct {
    bb: ?i32,

    pub const _desc_table = .{
        .bb = fd(1, .{ .Varint = .Simple }),
    };


    pub fn encode(self: NestedMessage, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !NestedMessage {
        return pb_decode(NestedMessage, input, allocator);
    }
    pub fn init(allocator: Allocator) NestedMessage {
        return pb_init(NestedMessage, allocator);
    }
    pub fn deinit(self: NestedMessage) void {
        return pb_deinit(self);
    }
};


    pub fn encode(self: TestAllTypes, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestAllTypes {
        return pb_decode(TestAllTypes, input, allocator);
    }
    pub fn init(allocator: Allocator) TestAllTypes {
        return pb_init(TestAllTypes, allocator);
    }
    pub fn deinit(self: TestAllTypes) void {
        return pb_deinit(self);
    }
};

pub const NestedTestAllTypes = struct {
    child: ?NestedTestAllTypes,
    payload: ?TestAllTypes,
    repeated_child: ArrayList(NestedTestAllTypes),
    lazy_child: ?NestedTestAllTypes,
    eager_child: ?TestAllTypes,

    pub const _desc_table = .{
        .child = fd(1, .{ .SubMessage = {} }),
        .payload = fd(2, .{ .SubMessage = {} }),
        .repeated_child = fd(3, .{ .List = .{ .SubMessage = {} }}),
        .lazy_child = fd(4, .{ .SubMessage = {} }),
        .eager_child = fd(5, .{ .SubMessage = {} }),
    };


    pub fn encode(self: NestedTestAllTypes, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !NestedTestAllTypes {
        return pb_decode(NestedTestAllTypes, input, allocator);
    }
    pub fn init(allocator: Allocator) NestedTestAllTypes {
        return pb_init(NestedTestAllTypes, allocator);
    }
    pub fn deinit(self: NestedTestAllTypes) void {
        return pb_deinit(self);
    }
};

pub const TestDeprecatedFields = struct {
    deprecated_int32: ?i32,
    deprecated_int32_in_oneof: ?i32,

    pub const _desc_table = .{
        .deprecated_int32 = fd(1, .{ .Varint = .Simple }),
        .deprecated_int32_in_oneof = fd(2, .{ .Varint = .Simple }),
    };


    pub fn encode(self: TestDeprecatedFields, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestDeprecatedFields {
        return pb_decode(TestDeprecatedFields, input, allocator);
    }
    pub fn init(allocator: Allocator) TestDeprecatedFields {
        return pb_init(TestDeprecatedFields, allocator);
    }
    pub fn deinit(self: TestDeprecatedFields) void {
        return pb_deinit(self);
    }
};

pub const TestDeprecatedMessage = struct {

    pub const _desc_table = .{
    };


    pub fn encode(self: TestDeprecatedMessage, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestDeprecatedMessage {
        return pb_decode(TestDeprecatedMessage, input, allocator);
    }
    pub fn init(allocator: Allocator) TestDeprecatedMessage {
        return pb_init(TestDeprecatedMessage, allocator);
    }
    pub fn deinit(self: TestDeprecatedMessage) void {
        return pb_deinit(self);
    }
};

pub const ForeignMessage = struct {
    c: ?i32,
    d: ?i32,

    pub const _desc_table = .{
        .c = fd(1, .{ .Varint = .Simple }),
        .d = fd(2, .{ .Varint = .Simple }),
    };


    pub fn encode(self: ForeignMessage, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !ForeignMessage {
        return pb_decode(ForeignMessage, input, allocator);
    }
    pub fn init(allocator: Allocator) ForeignMessage {
        return pb_init(ForeignMessage, allocator);
    }
    pub fn deinit(self: ForeignMessage) void {
        return pb_deinit(self);
    }
};

pub const TestReservedFields = struct {

    pub const _desc_table = .{
    };


    pub fn encode(self: TestReservedFields, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestReservedFields {
        return pb_decode(TestReservedFields, input, allocator);
    }
    pub fn init(allocator: Allocator) TestReservedFields {
        return pb_init(TestReservedFields, allocator);
    }
    pub fn deinit(self: TestReservedFields) void {
        return pb_deinit(self);
    }
};

pub const TestAllExtensions = struct {

    pub const _desc_table = .{
    };


    pub fn encode(self: TestAllExtensions, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestAllExtensions {
        return pb_decode(TestAllExtensions, input, allocator);
    }
    pub fn init(allocator: Allocator) TestAllExtensions {
        return pb_init(TestAllExtensions, allocator);
    }
    pub fn deinit(self: TestAllExtensions) void {
        return pb_deinit(self);
    }
};

pub const TestGroup = struct {
    a: ?i32,
    optional_foreign_enum: ?ForeignEnum,

    pub const _desc_table = .{
        .a = fd(17, .{ .Varint = .Simple }),
        .optional_foreign_enum = fd(22, .{ .Varint = .Simple }),
    };


    pub fn encode(self: TestGroup, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestGroup {
        return pb_decode(TestGroup, input, allocator);
    }
    pub fn init(allocator: Allocator) TestGroup {
        return pb_init(TestGroup, allocator);
    }
    pub fn deinit(self: TestGroup) void {
        return pb_deinit(self);
    }
};

pub const TestGroupExtension = struct {

    pub const _desc_table = .{
    };


    pub fn encode(self: TestGroupExtension, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestGroupExtension {
        return pb_decode(TestGroupExtension, input, allocator);
    }
    pub fn init(allocator: Allocator) TestGroupExtension {
        return pb_init(TestGroupExtension, allocator);
    }
    pub fn deinit(self: TestGroupExtension) void {
        return pb_deinit(self);
    }
};

pub const TestNestedExtension = struct {

    pub const _desc_table = .{
    };


    pub fn encode(self: TestNestedExtension, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestNestedExtension {
        return pb_decode(TestNestedExtension, input, allocator);
    }
    pub fn init(allocator: Allocator) TestNestedExtension {
        return pb_init(TestNestedExtension, allocator);
    }
    pub fn deinit(self: TestNestedExtension) void {
        return pb_deinit(self);
    }
};

pub const TestChildExtension = struct {
    a: ?[]const u8,
    b: ?[]const u8,
    optional_extension: ?TestAllExtensions,

    pub const _desc_table = .{
        .a = fd(1, .String),
        .b = fd(2, .String),
        .optional_extension = fd(3, .{ .SubMessage = {} }),
    };


    pub fn encode(self: TestChildExtension, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestChildExtension {
        return pb_decode(TestChildExtension, input, allocator);
    }
    pub fn init(allocator: Allocator) TestChildExtension {
        return pb_init(TestChildExtension, allocator);
    }
    pub fn deinit(self: TestChildExtension) void {
        return pb_deinit(self);
    }
};

pub const TestChildExtensionData = struct {
    a: ?[]const u8,
    b: ?[]const u8,
    optional_extension: ?NestedTestAllExtensionsData,

    pub const _desc_table = .{
        .a = fd(1, .String),
        .b = fd(2, .String),
        .optional_extension = fd(3, .{ .SubMessage = {} }),
    };

pub const NestedTestAllExtensionsData = struct {
    dynamic: ?NestedDynamicExtensions,

    pub const _desc_table = .{
        .dynamic = fd(409707008, .{ .SubMessage = {} }),
    };

pub const NestedDynamicExtensions = struct {
    a: ?i32,
    b: ?i32,

    pub const _desc_table = .{
        .a = fd(1, .{ .Varint = .Simple }),
        .b = fd(2, .{ .Varint = .Simple }),
    };


    pub fn encode(self: NestedDynamicExtensions, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !NestedDynamicExtensions {
        return pb_decode(NestedDynamicExtensions, input, allocator);
    }
    pub fn init(allocator: Allocator) NestedDynamicExtensions {
        return pb_init(NestedDynamicExtensions, allocator);
    }
    pub fn deinit(self: NestedDynamicExtensions) void {
        return pb_deinit(self);
    }
};


    pub fn encode(self: NestedTestAllExtensionsData, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !NestedTestAllExtensionsData {
        return pb_decode(NestedTestAllExtensionsData, input, allocator);
    }
    pub fn init(allocator: Allocator) NestedTestAllExtensionsData {
        return pb_init(NestedTestAllExtensionsData, allocator);
    }
    pub fn deinit(self: NestedTestAllExtensionsData) void {
        return pb_deinit(self);
    }
};


    pub fn encode(self: TestChildExtensionData, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestChildExtensionData {
        return pb_decode(TestChildExtensionData, input, allocator);
    }
    pub fn init(allocator: Allocator) TestChildExtensionData {
        return pb_init(TestChildExtensionData, allocator);
    }
    pub fn deinit(self: TestChildExtensionData) void {
        return pb_deinit(self);
    }
};

pub const TestNestedChildExtension = struct {
    a: ?i32,
    child: ?TestChildExtension,

    pub const _desc_table = .{
        .a = fd(1, .{ .Varint = .Simple }),
        .child = fd(2, .{ .SubMessage = {} }),
    };


    pub fn encode(self: TestNestedChildExtension, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestNestedChildExtension {
        return pb_decode(TestNestedChildExtension, input, allocator);
    }
    pub fn init(allocator: Allocator) TestNestedChildExtension {
        return pb_init(TestNestedChildExtension, allocator);
    }
    pub fn deinit(self: TestNestedChildExtension) void {
        return pb_deinit(self);
    }
};

pub const TestNestedChildExtensionData = struct {
    a: ?i32,
    child: ?TestChildExtensionData,

    pub const _desc_table = .{
        .a = fd(1, .{ .Varint = .Simple }),
        .child = fd(2, .{ .SubMessage = {} }),
    };


    pub fn encode(self: TestNestedChildExtensionData, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestNestedChildExtensionData {
        return pb_decode(TestNestedChildExtensionData, input, allocator);
    }
    pub fn init(allocator: Allocator) TestNestedChildExtensionData {
        return pb_init(TestNestedChildExtensionData, allocator);
    }
    pub fn deinit(self: TestNestedChildExtensionData) void {
        return pb_deinit(self);
    }
};

pub const TestRequired = struct {
    a: i32,
    dummy2: ?i32,
    b: i32,
    dummy4: ?i32,
    dummy5: ?i32,
    dummy6: ?i32,
    dummy7: ?i32,
    dummy8: ?i32,
    dummy9: ?i32,
    dummy10: ?i32,
    dummy11: ?i32,
    dummy12: ?i32,
    dummy13: ?i32,
    dummy14: ?i32,
    dummy15: ?i32,
    dummy16: ?i32,
    dummy17: ?i32,
    dummy18: ?i32,
    dummy19: ?i32,
    dummy20: ?i32,
    dummy21: ?i32,
    dummy22: ?i32,
    dummy23: ?i32,
    dummy24: ?i32,
    dummy25: ?i32,
    dummy26: ?i32,
    dummy27: ?i32,
    dummy28: ?i32,
    dummy29: ?i32,
    dummy30: ?i32,
    dummy31: ?i32,
    dummy32: ?i32,
    c: i32,
    optional_foreign: ?ForeignMessage,

    pub const _desc_table = .{
        .a = fd(1, .{ .Varint = .Simple }),
        .dummy2 = fd(2, .{ .Varint = .Simple }),
        .b = fd(3, .{ .Varint = .Simple }),
        .dummy4 = fd(4, .{ .Varint = .Simple }),
        .dummy5 = fd(5, .{ .Varint = .Simple }),
        .dummy6 = fd(6, .{ .Varint = .Simple }),
        .dummy7 = fd(7, .{ .Varint = .Simple }),
        .dummy8 = fd(8, .{ .Varint = .Simple }),
        .dummy9 = fd(9, .{ .Varint = .Simple }),
        .dummy10 = fd(10, .{ .Varint = .Simple }),
        .dummy11 = fd(11, .{ .Varint = .Simple }),
        .dummy12 = fd(12, .{ .Varint = .Simple }),
        .dummy13 = fd(13, .{ .Varint = .Simple }),
        .dummy14 = fd(14, .{ .Varint = .Simple }),
        .dummy15 = fd(15, .{ .Varint = .Simple }),
        .dummy16 = fd(16, .{ .Varint = .Simple }),
        .dummy17 = fd(17, .{ .Varint = .Simple }),
        .dummy18 = fd(18, .{ .Varint = .Simple }),
        .dummy19 = fd(19, .{ .Varint = .Simple }),
        .dummy20 = fd(20, .{ .Varint = .Simple }),
        .dummy21 = fd(21, .{ .Varint = .Simple }),
        .dummy22 = fd(22, .{ .Varint = .Simple }),
        .dummy23 = fd(23, .{ .Varint = .Simple }),
        .dummy24 = fd(24, .{ .Varint = .Simple }),
        .dummy25 = fd(25, .{ .Varint = .Simple }),
        .dummy26 = fd(26, .{ .Varint = .Simple }),
        .dummy27 = fd(27, .{ .Varint = .Simple }),
        .dummy28 = fd(28, .{ .Varint = .Simple }),
        .dummy29 = fd(29, .{ .Varint = .Simple }),
        .dummy30 = fd(30, .{ .Varint = .Simple }),
        .dummy31 = fd(31, .{ .Varint = .Simple }),
        .dummy32 = fd(32, .{ .Varint = .Simple }),
        .c = fd(33, .{ .Varint = .Simple }),
        .optional_foreign = fd(34, .{ .SubMessage = {} }),
    };


    pub fn encode(self: TestRequired, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestRequired {
        return pb_decode(TestRequired, input, allocator);
    }
    pub fn init(allocator: Allocator) TestRequired {
        return pb_init(TestRequired, allocator);
    }
    pub fn deinit(self: TestRequired) void {
        return pb_deinit(self);
    }
};

pub const TestRequiredForeign = struct {
    optional_message: ?TestRequired,
    repeated_message: ArrayList(TestRequired),
    dummy: ?i32,
    optional_lazy_message: ?NestedTestAllTypes,

    pub const _desc_table = .{
        .optional_message = fd(1, .{ .SubMessage = {} }),
        .repeated_message = fd(2, .{ .List = .{ .SubMessage = {} }}),
        .dummy = fd(3, .{ .Varint = .Simple }),
        .optional_lazy_message = fd(4, .{ .SubMessage = {} }),
    };


    pub fn encode(self: TestRequiredForeign, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestRequiredForeign {
        return pb_decode(TestRequiredForeign, input, allocator);
    }
    pub fn init(allocator: Allocator) TestRequiredForeign {
        return pb_init(TestRequiredForeign, allocator);
    }
    pub fn deinit(self: TestRequiredForeign) void {
        return pb_deinit(self);
    }
};

pub const TestRequiredMessage = struct {
    optional_message: ?TestRequired,
    repeated_message: ArrayList(TestRequired),
    required_message: ?TestRequired,

    pub const _desc_table = .{
        .optional_message = fd(1, .{ .SubMessage = {} }),
        .repeated_message = fd(2, .{ .List = .{ .SubMessage = {} }}),
        .required_message = fd(3, .{ .SubMessage = {} }),
    };


    pub fn encode(self: TestRequiredMessage, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestRequiredMessage {
        return pb_decode(TestRequiredMessage, input, allocator);
    }
    pub fn init(allocator: Allocator) TestRequiredMessage {
        return pb_init(TestRequiredMessage, allocator);
    }
    pub fn deinit(self: TestRequiredMessage) void {
        return pb_deinit(self);
    }
};

pub const TestNestedRequiredForeign = struct {
    child: ?TestNestedRequiredForeign,
    payload: ?TestRequiredForeign,
    dummy: ?i32,

    pub const _desc_table = .{
        .child = fd(1, .{ .SubMessage = {} }),
        .payload = fd(2, .{ .SubMessage = {} }),
        .dummy = fd(3, .{ .Varint = .Simple }),
    };


    pub fn encode(self: TestNestedRequiredForeign, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestNestedRequiredForeign {
        return pb_decode(TestNestedRequiredForeign, input, allocator);
    }
    pub fn init(allocator: Allocator) TestNestedRequiredForeign {
        return pb_init(TestNestedRequiredForeign, allocator);
    }
    pub fn deinit(self: TestNestedRequiredForeign) void {
        return pb_deinit(self);
    }
};

pub const TestForeignNested = struct {
    foreign_nested: ?TestAllTypes.NestedMessage,

    pub const _desc_table = .{
        .foreign_nested = fd(1, .{ .SubMessage = {} }),
    };


    pub fn encode(self: TestForeignNested, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestForeignNested {
        return pb_decode(TestForeignNested, input, allocator);
    }
    pub fn init(allocator: Allocator) TestForeignNested {
        return pb_init(TestForeignNested, allocator);
    }
    pub fn deinit(self: TestForeignNested) void {
        return pb_deinit(self);
    }
};

pub const TestEmptyMessage = struct {

    pub const _desc_table = .{
    };


    pub fn encode(self: TestEmptyMessage, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestEmptyMessage {
        return pb_decode(TestEmptyMessage, input, allocator);
    }
    pub fn init(allocator: Allocator) TestEmptyMessage {
        return pb_init(TestEmptyMessage, allocator);
    }
    pub fn deinit(self: TestEmptyMessage) void {
        return pb_deinit(self);
    }
};

pub const TestEmptyMessageWithExtensions = struct {

    pub const _desc_table = .{
    };


    pub fn encode(self: TestEmptyMessageWithExtensions, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestEmptyMessageWithExtensions {
        return pb_decode(TestEmptyMessageWithExtensions, input, allocator);
    }
    pub fn init(allocator: Allocator) TestEmptyMessageWithExtensions {
        return pb_init(TestEmptyMessageWithExtensions, allocator);
    }
    pub fn deinit(self: TestEmptyMessageWithExtensions) void {
        return pb_deinit(self);
    }
};

pub const TestPickleNestedMessage = struct {

    pub const _desc_table = .{
    };

pub const NestedMessage = struct {
    bb: ?i32,

    pub const _desc_table = .{
        .bb = fd(1, .{ .Varint = .Simple }),
    };

pub const NestedNestedMessage = struct {
    cc: ?i32,

    pub const _desc_table = .{
        .cc = fd(1, .{ .Varint = .Simple }),
    };


    pub fn encode(self: NestedNestedMessage, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !NestedNestedMessage {
        return pb_decode(NestedNestedMessage, input, allocator);
    }
    pub fn init(allocator: Allocator) NestedNestedMessage {
        return pb_init(NestedNestedMessage, allocator);
    }
    pub fn deinit(self: NestedNestedMessage) void {
        return pb_deinit(self);
    }
};


    pub fn encode(self: NestedMessage, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !NestedMessage {
        return pb_decode(NestedMessage, input, allocator);
    }
    pub fn init(allocator: Allocator) NestedMessage {
        return pb_init(NestedMessage, allocator);
    }
    pub fn deinit(self: NestedMessage) void {
        return pb_deinit(self);
    }
};


    pub fn encode(self: TestPickleNestedMessage, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestPickleNestedMessage {
        return pb_decode(TestPickleNestedMessage, input, allocator);
    }
    pub fn init(allocator: Allocator) TestPickleNestedMessage {
        return pb_init(TestPickleNestedMessage, allocator);
    }
    pub fn deinit(self: TestPickleNestedMessage) void {
        return pb_deinit(self);
    }
};

pub const TestMultipleExtensionRanges = struct {

    pub const _desc_table = .{
    };


    pub fn encode(self: TestMultipleExtensionRanges, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestMultipleExtensionRanges {
        return pb_decode(TestMultipleExtensionRanges, input, allocator);
    }
    pub fn init(allocator: Allocator) TestMultipleExtensionRanges {
        return pb_init(TestMultipleExtensionRanges, allocator);
    }
    pub fn deinit(self: TestMultipleExtensionRanges) void {
        return pb_deinit(self);
    }
};

pub const TestReallyLargeTagNumber = struct {
    a: ?i32,
    bb: ?i32,

    pub const _desc_table = .{
        .a = fd(1, .{ .Varint = .Simple }),
        .bb = fd(268435455, .{ .Varint = .Simple }),
    };


    pub fn encode(self: TestReallyLargeTagNumber, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestReallyLargeTagNumber {
        return pb_decode(TestReallyLargeTagNumber, input, allocator);
    }
    pub fn init(allocator: Allocator) TestReallyLargeTagNumber {
        return pb_init(TestReallyLargeTagNumber, allocator);
    }
    pub fn deinit(self: TestReallyLargeTagNumber) void {
        return pb_deinit(self);
    }
};

pub const TestRecursiveMessage = struct {
    a: ?TestRecursiveMessage,
    i: ?i32,

    pub const _desc_table = .{
        .a = fd(1, .{ .SubMessage = {} }),
        .i = fd(2, .{ .Varint = .Simple }),
    };


    pub fn encode(self: TestRecursiveMessage, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestRecursiveMessage {
        return pb_decode(TestRecursiveMessage, input, allocator);
    }
    pub fn init(allocator: Allocator) TestRecursiveMessage {
        return pb_init(TestRecursiveMessage, allocator);
    }
    pub fn deinit(self: TestRecursiveMessage) void {
        return pb_deinit(self);
    }
};

pub const TestMutualRecursionA = struct {
    bb: ?TestMutualRecursionB,
    sub_message: ?SubMessage,
    not_in_this_scc: ?TestAllTypes,

    pub const _desc_table = .{
        .bb = fd(1, .{ .SubMessage = {} }),
        .sub_message = fd(3, .{ .SubMessage = {} }),
        .not_in_this_scc = fd(4, .{ .SubMessage = {} }),
    };

pub const SubMessage = struct {
    b: ?TestMutualRecursionB,

    pub const _desc_table = .{
        .b = fd(1, .{ .SubMessage = {} }),
    };


    pub fn encode(self: SubMessage, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !SubMessage {
        return pb_decode(SubMessage, input, allocator);
    }
    pub fn init(allocator: Allocator) SubMessage {
        return pb_init(SubMessage, allocator);
    }
    pub fn deinit(self: SubMessage) void {
        return pb_deinit(self);
    }
};


    pub fn encode(self: TestMutualRecursionA, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestMutualRecursionA {
        return pb_decode(TestMutualRecursionA, input, allocator);
    }
    pub fn init(allocator: Allocator) TestMutualRecursionA {
        return pb_init(TestMutualRecursionA, allocator);
    }
    pub fn deinit(self: TestMutualRecursionA) void {
        return pb_deinit(self);
    }
};

pub const TestMutualRecursionB = struct {
    a: ?TestMutualRecursionA,
    optional_int32: ?i32,

    pub const _desc_table = .{
        .a = fd(1, .{ .SubMessage = {} }),
        .optional_int32 = fd(2, .{ .Varint = .Simple }),
    };


    pub fn encode(self: TestMutualRecursionB, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestMutualRecursionB {
        return pb_decode(TestMutualRecursionB, input, allocator);
    }
    pub fn init(allocator: Allocator) TestMutualRecursionB {
        return pb_init(TestMutualRecursionB, allocator);
    }
    pub fn deinit(self: TestMutualRecursionB) void {
        return pb_deinit(self);
    }
};

pub const TestIsInitialized = struct {
    sub_message: ?SubMessage,

    pub const _desc_table = .{
        .sub_message = fd(1, .{ .SubMessage = {} }),
    };

pub const SubMessage = struct {
    i: i32,

    pub const _desc_table = .{
        .i = fd(2, .{ .Varint = .Simple }),
    };


    pub fn encode(self: SubMessage, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !SubMessage {
        return pb_decode(SubMessage, input, allocator);
    }
    pub fn init(allocator: Allocator) SubMessage {
        return pb_init(SubMessage, allocator);
    }
    pub fn deinit(self: SubMessage) void {
        return pb_deinit(self);
    }
};


    pub fn encode(self: TestIsInitialized, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestIsInitialized {
        return pb_decode(TestIsInitialized, input, allocator);
    }
    pub fn init(allocator: Allocator) TestIsInitialized {
        return pb_init(TestIsInitialized, allocator);
    }
    pub fn deinit(self: TestIsInitialized) void {
        return pb_deinit(self);
    }
};

pub const TestDupFieldNumber = struct {
    a: ?i32,

    pub const _desc_table = .{
        .a = fd(1, .{ .Varint = .Simple }),
    };


    pub fn encode(self: TestDupFieldNumber, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestDupFieldNumber {
        return pb_decode(TestDupFieldNumber, input, allocator);
    }
    pub fn init(allocator: Allocator) TestDupFieldNumber {
        return pb_init(TestDupFieldNumber, allocator);
    }
    pub fn deinit(self: TestDupFieldNumber) void {
        return pb_deinit(self);
    }
};

pub const TestEagerMessage = struct {
    sub_message: ?TestAllTypes,

    pub const _desc_table = .{
        .sub_message = fd(1, .{ .SubMessage = {} }),
    };


    pub fn encode(self: TestEagerMessage, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestEagerMessage {
        return pb_decode(TestEagerMessage, input, allocator);
    }
    pub fn init(allocator: Allocator) TestEagerMessage {
        return pb_init(TestEagerMessage, allocator);
    }
    pub fn deinit(self: TestEagerMessage) void {
        return pb_deinit(self);
    }
};

pub const TestLazyMessage = struct {
    sub_message: ?TestAllTypes,

    pub const _desc_table = .{
        .sub_message = fd(1, .{ .SubMessage = {} }),
    };


    pub fn encode(self: TestLazyMessage, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestLazyMessage {
        return pb_decode(TestLazyMessage, input, allocator);
    }
    pub fn init(allocator: Allocator) TestLazyMessage {
        return pb_init(TestLazyMessage, allocator);
    }
    pub fn deinit(self: TestLazyMessage) void {
        return pb_deinit(self);
    }
};

pub const TestEagerMaybeLazy = struct {
    message_foo: ?TestAllTypes,
    message_bar: ?TestAllTypes,
    message_baz: ?NestedMessage,

    pub const _desc_table = .{
        .message_foo = fd(1, .{ .SubMessage = {} }),
        .message_bar = fd(2, .{ .SubMessage = {} }),
        .message_baz = fd(3, .{ .SubMessage = {} }),
    };

pub const NestedMessage = struct {
    @"packed": ?TestPackedTypes,

    pub const _desc_table = .{
        .@"packed" = fd(1, .{ .SubMessage = {} }),
    };


    pub fn encode(self: NestedMessage, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !NestedMessage {
        return pb_decode(NestedMessage, input, allocator);
    }
    pub fn init(allocator: Allocator) NestedMessage {
        return pb_init(NestedMessage, allocator);
    }
    pub fn deinit(self: NestedMessage) void {
        return pb_deinit(self);
    }
};


    pub fn encode(self: TestEagerMaybeLazy, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestEagerMaybeLazy {
        return pb_decode(TestEagerMaybeLazy, input, allocator);
    }
    pub fn init(allocator: Allocator) TestEagerMaybeLazy {
        return pb_init(TestEagerMaybeLazy, allocator);
    }
    pub fn deinit(self: TestEagerMaybeLazy) void {
        return pb_deinit(self);
    }
};

pub const TestNestedMessageHasBits = struct {
    optional_nested_message: ?NestedMessage,

    pub const _desc_table = .{
        .optional_nested_message = fd(1, .{ .SubMessage = {} }),
    };

pub const NestedMessage = struct {
    nestedmessage_repeated_int32: ArrayList(i32),
    nestedmessage_repeated_foreignmessage: ArrayList(ForeignMessage),

    pub const _desc_table = .{
        .nestedmessage_repeated_int32 = fd(1, .{ .List = .{ .Varint = .Simple }}),
        .nestedmessage_repeated_foreignmessage = fd(2, .{ .List = .{ .SubMessage = {} }}),
    };


    pub fn encode(self: NestedMessage, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !NestedMessage {
        return pb_decode(NestedMessage, input, allocator);
    }
    pub fn init(allocator: Allocator) NestedMessage {
        return pb_init(NestedMessage, allocator);
    }
    pub fn deinit(self: NestedMessage) void {
        return pb_deinit(self);
    }
};


    pub fn encode(self: TestNestedMessageHasBits, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestNestedMessageHasBits {
        return pb_decode(TestNestedMessageHasBits, input, allocator);
    }
    pub fn init(allocator: Allocator) TestNestedMessageHasBits {
        return pb_init(TestNestedMessageHasBits, allocator);
    }
    pub fn deinit(self: TestNestedMessageHasBits) void {
        return pb_deinit(self);
    }
};

pub const TestCamelCaseFieldNames = struct {
    PrimitiveField: ?i32,
    StringField: ?[]const u8,
    EnumField: ?ForeignEnum,
    MessageField: ?ForeignMessage,
    StringPieceField: ?[]const u8,
    CordField: ?[]const u8,
    RepeatedPrimitiveField: ArrayList(i32),
    RepeatedStringField: ArrayList([]const u8),
    RepeatedEnumField: ArrayList(ForeignEnum),
    RepeatedMessageField: ArrayList(ForeignMessage),
    RepeatedStringPieceField: ArrayList([]const u8),
    RepeatedCordField: ArrayList([]const u8),

    pub const _desc_table = .{
        .PrimitiveField = fd(1, .{ .Varint = .Simple }),
        .StringField = fd(2, .String),
        .EnumField = fd(3, .{ .Varint = .Simple }),
        .MessageField = fd(4, .{ .SubMessage = {} }),
        .StringPieceField = fd(5, .String),
        .CordField = fd(6, .String),
        .RepeatedPrimitiveField = fd(7, .{ .List = .{ .Varint = .Simple }}),
        .RepeatedStringField = fd(8, .{ .List = .String}),
        .RepeatedEnumField = fd(9, .{ .List = .{ .Varint = .Simple }}),
        .RepeatedMessageField = fd(10, .{ .List = .{ .SubMessage = {} }}),
        .RepeatedStringPieceField = fd(11, .{ .List = .String}),
        .RepeatedCordField = fd(12, .{ .List = .String}),
    };


    pub fn encode(self: TestCamelCaseFieldNames, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestCamelCaseFieldNames {
        return pb_decode(TestCamelCaseFieldNames, input, allocator);
    }
    pub fn init(allocator: Allocator) TestCamelCaseFieldNames {
        return pb_init(TestCamelCaseFieldNames, allocator);
    }
    pub fn deinit(self: TestCamelCaseFieldNames) void {
        return pb_deinit(self);
    }
};

pub const TestFieldOrderings = struct {
    my_string: ?[]const u8,
    my_int: ?i64,
    my_float: ?f32,
    optional_nested_message: ?NestedMessage,

    pub const _desc_table = .{
        .my_string = fd(11, .String),
        .my_int = fd(1, .{ .Varint = .Simple }),
        .my_float = fd(101, .{ .FixedInt = .I32 }),
        .optional_nested_message = fd(200, .{ .SubMessage = {} }),
    };

pub const NestedMessage = struct {
    oo: ?i64,
    bb: ?i32,

    pub const _desc_table = .{
        .oo = fd(2, .{ .Varint = .Simple }),
        .bb = fd(1, .{ .Varint = .Simple }),
    };


    pub fn encode(self: NestedMessage, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !NestedMessage {
        return pb_decode(NestedMessage, input, allocator);
    }
    pub fn init(allocator: Allocator) NestedMessage {
        return pb_init(NestedMessage, allocator);
    }
    pub fn deinit(self: NestedMessage) void {
        return pb_deinit(self);
    }
};


    pub fn encode(self: TestFieldOrderings, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestFieldOrderings {
        return pb_decode(TestFieldOrderings, input, allocator);
    }
    pub fn init(allocator: Allocator) TestFieldOrderings {
        return pb_init(TestFieldOrderings, allocator);
    }
    pub fn deinit(self: TestFieldOrderings) void {
        return pb_deinit(self);
    }
};

pub const TestExtensionOrderings1 = struct {
    my_string: ?[]const u8,

    pub const _desc_table = .{
        .my_string = fd(1, .String),
    };


    pub fn encode(self: TestExtensionOrderings1, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestExtensionOrderings1 {
        return pb_decode(TestExtensionOrderings1, input, allocator);
    }
    pub fn init(allocator: Allocator) TestExtensionOrderings1 {
        return pb_init(TestExtensionOrderings1, allocator);
    }
    pub fn deinit(self: TestExtensionOrderings1) void {
        return pb_deinit(self);
    }
};

pub const TestExtensionOrderings2 = struct {
    my_string: ?[]const u8,

    pub const _desc_table = .{
        .my_string = fd(1, .String),
    };

pub const TestExtensionOrderings3 = struct {
    my_string: ?[]const u8,

    pub const _desc_table = .{
        .my_string = fd(1, .String),
    };


    pub fn encode(self: TestExtensionOrderings3, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestExtensionOrderings3 {
        return pb_decode(TestExtensionOrderings3, input, allocator);
    }
    pub fn init(allocator: Allocator) TestExtensionOrderings3 {
        return pb_init(TestExtensionOrderings3, allocator);
    }
    pub fn deinit(self: TestExtensionOrderings3) void {
        return pb_deinit(self);
    }
};


    pub fn encode(self: TestExtensionOrderings2, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestExtensionOrderings2 {
        return pb_decode(TestExtensionOrderings2, input, allocator);
    }
    pub fn init(allocator: Allocator) TestExtensionOrderings2 {
        return pb_init(TestExtensionOrderings2, allocator);
    }
    pub fn deinit(self: TestExtensionOrderings2) void {
        return pb_deinit(self);
    }
};

pub const TestExtremeDefaultValues = struct {
    escaped_bytes: ?[]const u8,
    large_uint32: ?u32,
    large_uint64: ?u64,
    small_int32: ?i32,
    small_int64: ?i64,
    really_small_int32: ?i32,
    really_small_int64: ?i64,
    utf8_string: ?[]const u8,
    zero_float: ?f32,
    one_float: ?f32,
    small_float: ?f32,
    negative_one_float: ?f32,
    negative_float: ?f32,
    large_float: ?f32,
    small_negative_float: ?f32,
    inf_double: ?f64,
    neg_inf_double: ?f64,
    nan_double: ?f64,
    inf_float: ?f32,
    neg_inf_float: ?f32,
    nan_float: ?f32,
    cpp_trigraph: ?[]const u8,
    string_with_zero: ?[]const u8,
    bytes_with_zero: ?[]const u8,
    string_piece_with_zero: ?[]const u8,
    cord_with_zero: ?[]const u8,
    replacement_string: ?[]const u8,

    pub const _desc_table = .{
        .escaped_bytes = fd(1, .String),
        .large_uint32 = fd(2, .{ .Varint = .Simple }),
        .large_uint64 = fd(3, .{ .Varint = .Simple }),
        .small_int32 = fd(4, .{ .Varint = .Simple }),
        .small_int64 = fd(5, .{ .Varint = .Simple }),
        .really_small_int32 = fd(21, .{ .Varint = .Simple }),
        .really_small_int64 = fd(22, .{ .Varint = .Simple }),
        .utf8_string = fd(6, .String),
        .zero_float = fd(7, .{ .FixedInt = .I32 }),
        .one_float = fd(8, .{ .FixedInt = .I32 }),
        .small_float = fd(9, .{ .FixedInt = .I32 }),
        .negative_one_float = fd(10, .{ .FixedInt = .I32 }),
        .negative_float = fd(11, .{ .FixedInt = .I32 }),
        .large_float = fd(12, .{ .FixedInt = .I32 }),
        .small_negative_float = fd(13, .{ .FixedInt = .I32 }),
        .inf_double = fd(14, .{ .FixedInt = .I64 }),
        .neg_inf_double = fd(15, .{ .FixedInt = .I64 }),
        .nan_double = fd(16, .{ .FixedInt = .I64 }),
        .inf_float = fd(17, .{ .FixedInt = .I32 }),
        .neg_inf_float = fd(18, .{ .FixedInt = .I32 }),
        .nan_float = fd(19, .{ .FixedInt = .I32 }),
        .cpp_trigraph = fd(20, .String),
        .string_with_zero = fd(23, .String),
        .bytes_with_zero = fd(24, .String),
        .string_piece_with_zero = fd(25, .String),
        .cord_with_zero = fd(26, .String),
        .replacement_string = fd(27, .String),
    };


    pub fn encode(self: TestExtremeDefaultValues, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestExtremeDefaultValues {
        return pb_decode(TestExtremeDefaultValues, input, allocator);
    }
    pub fn init(allocator: Allocator) TestExtremeDefaultValues {
        return pb_init(TestExtremeDefaultValues, allocator);
    }
    pub fn deinit(self: TestExtremeDefaultValues) void {
        return pb_deinit(self);
    }
};

pub const SparseEnumMessage = struct {
    sparse_enum: ?TestSparseEnum,

    pub const _desc_table = .{
        .sparse_enum = fd(1, .{ .Varint = .Simple }),
    };


    pub fn encode(self: SparseEnumMessage, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !SparseEnumMessage {
        return pb_decode(SparseEnumMessage, input, allocator);
    }
    pub fn init(allocator: Allocator) SparseEnumMessage {
        return pb_init(SparseEnumMessage, allocator);
    }
    pub fn deinit(self: SparseEnumMessage) void {
        return pb_deinit(self);
    }
};

pub const OneString = struct {
    data: ?[]const u8,

    pub const _desc_table = .{
        .data = fd(1, .String),
    };


    pub fn encode(self: OneString, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !OneString {
        return pb_decode(OneString, input, allocator);
    }
    pub fn init(allocator: Allocator) OneString {
        return pb_init(OneString, allocator);
    }
    pub fn deinit(self: OneString) void {
        return pb_deinit(self);
    }
};

pub const MoreString = struct {
    data: ArrayList([]const u8),

    pub const _desc_table = .{
        .data = fd(1, .{ .List = .String}),
    };


    pub fn encode(self: MoreString, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !MoreString {
        return pb_decode(MoreString, input, allocator);
    }
    pub fn init(allocator: Allocator) MoreString {
        return pb_init(MoreString, allocator);
    }
    pub fn deinit(self: MoreString) void {
        return pb_deinit(self);
    }
};

pub const OneBytes = struct {
    data: ?[]const u8,

    pub const _desc_table = .{
        .data = fd(1, .String),
    };


    pub fn encode(self: OneBytes, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !OneBytes {
        return pb_decode(OneBytes, input, allocator);
    }
    pub fn init(allocator: Allocator) OneBytes {
        return pb_init(OneBytes, allocator);
    }
    pub fn deinit(self: OneBytes) void {
        return pb_deinit(self);
    }
};

pub const MoreBytes = struct {
    data: ArrayList([]const u8),

    pub const _desc_table = .{
        .data = fd(1, .{ .List = .String}),
    };


    pub fn encode(self: MoreBytes, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !MoreBytes {
        return pb_decode(MoreBytes, input, allocator);
    }
    pub fn init(allocator: Allocator) MoreBytes {
        return pb_init(MoreBytes, allocator);
    }
    pub fn deinit(self: MoreBytes) void {
        return pb_deinit(self);
    }
};

pub const ManyOptionalString = struct {
    str1: ?[]const u8,
    str2: ?[]const u8,
    str3: ?[]const u8,
    str4: ?[]const u8,
    str5: ?[]const u8,
    str6: ?[]const u8,
    str7: ?[]const u8,
    str8: ?[]const u8,
    str9: ?[]const u8,
    str10: ?[]const u8,
    str11: ?[]const u8,
    str12: ?[]const u8,
    str13: ?[]const u8,
    str14: ?[]const u8,
    str15: ?[]const u8,
    str16: ?[]const u8,
    str17: ?[]const u8,
    str18: ?[]const u8,
    str19: ?[]const u8,
    str20: ?[]const u8,
    str21: ?[]const u8,
    str22: ?[]const u8,
    str23: ?[]const u8,
    str24: ?[]const u8,
    str25: ?[]const u8,
    str26: ?[]const u8,
    str27: ?[]const u8,
    str28: ?[]const u8,
    str29: ?[]const u8,
    str30: ?[]const u8,
    str31: ?[]const u8,
    str32: ?[]const u8,

    pub const _desc_table = .{
        .str1 = fd(1, .String),
        .str2 = fd(2, .String),
        .str3 = fd(3, .String),
        .str4 = fd(4, .String),
        .str5 = fd(5, .String),
        .str6 = fd(6, .String),
        .str7 = fd(7, .String),
        .str8 = fd(8, .String),
        .str9 = fd(9, .String),
        .str10 = fd(10, .String),
        .str11 = fd(11, .String),
        .str12 = fd(12, .String),
        .str13 = fd(13, .String),
        .str14 = fd(14, .String),
        .str15 = fd(15, .String),
        .str16 = fd(16, .String),
        .str17 = fd(17, .String),
        .str18 = fd(18, .String),
        .str19 = fd(19, .String),
        .str20 = fd(20, .String),
        .str21 = fd(21, .String),
        .str22 = fd(22, .String),
        .str23 = fd(23, .String),
        .str24 = fd(24, .String),
        .str25 = fd(25, .String),
        .str26 = fd(26, .String),
        .str27 = fd(27, .String),
        .str28 = fd(28, .String),
        .str29 = fd(29, .String),
        .str30 = fd(30, .String),
        .str31 = fd(31, .String),
        .str32 = fd(32, .String),
    };


    pub fn encode(self: ManyOptionalString, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !ManyOptionalString {
        return pb_decode(ManyOptionalString, input, allocator);
    }
    pub fn init(allocator: Allocator) ManyOptionalString {
        return pb_init(ManyOptionalString, allocator);
    }
    pub fn deinit(self: ManyOptionalString) void {
        return pb_deinit(self);
    }
};

pub const Int32Message = struct {
    data: ?i32,

    pub const _desc_table = .{
        .data = fd(1, .{ .Varint = .Simple }),
    };


    pub fn encode(self: Int32Message, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !Int32Message {
        return pb_decode(Int32Message, input, allocator);
    }
    pub fn init(allocator: Allocator) Int32Message {
        return pb_init(Int32Message, allocator);
    }
    pub fn deinit(self: Int32Message) void {
        return pb_deinit(self);
    }
};

pub const Uint32Message = struct {
    data: ?u32,

    pub const _desc_table = .{
        .data = fd(1, .{ .Varint = .Simple }),
    };


    pub fn encode(self: Uint32Message, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !Uint32Message {
        return pb_decode(Uint32Message, input, allocator);
    }
    pub fn init(allocator: Allocator) Uint32Message {
        return pb_init(Uint32Message, allocator);
    }
    pub fn deinit(self: Uint32Message) void {
        return pb_deinit(self);
    }
};

pub const Int64Message = struct {
    data: ?i64,

    pub const _desc_table = .{
        .data = fd(1, .{ .Varint = .Simple }),
    };


    pub fn encode(self: Int64Message, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !Int64Message {
        return pb_decode(Int64Message, input, allocator);
    }
    pub fn init(allocator: Allocator) Int64Message {
        return pb_init(Int64Message, allocator);
    }
    pub fn deinit(self: Int64Message) void {
        return pb_deinit(self);
    }
};

pub const Uint64Message = struct {
    data: ?u64,

    pub const _desc_table = .{
        .data = fd(1, .{ .Varint = .Simple }),
    };


    pub fn encode(self: Uint64Message, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !Uint64Message {
        return pb_decode(Uint64Message, input, allocator);
    }
    pub fn init(allocator: Allocator) Uint64Message {
        return pb_init(Uint64Message, allocator);
    }
    pub fn deinit(self: Uint64Message) void {
        return pb_deinit(self);
    }
};

pub const BoolMessage = struct {
    data: ?bool,

    pub const _desc_table = .{
        .data = fd(1, .{ .Varint = .Simple }),
    };


    pub fn encode(self: BoolMessage, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !BoolMessage {
        return pb_decode(BoolMessage, input, allocator);
    }
    pub fn init(allocator: Allocator) BoolMessage {
        return pb_init(BoolMessage, allocator);
    }
    pub fn deinit(self: BoolMessage) void {
        return pb_deinit(self);
    }
};

pub const TestOneof = struct {
    foo_int: ?i32,
    foo_string: ?[]const u8,
    foo_message: ?TestAllTypes,
    a: ?i32,
    b: ?[]const u8,

    pub const _desc_table = .{
        .foo_int = fd(1, .{ .Varint = .Simple }),
        .foo_string = fd(2, .String),
        .foo_message = fd(3, .{ .SubMessage = {} }),
        .a = fd(5, .{ .Varint = .Simple }),
        .b = fd(6, .String),
    };


    pub fn encode(self: TestOneof, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestOneof {
        return pb_decode(TestOneof, input, allocator);
    }
    pub fn init(allocator: Allocator) TestOneof {
        return pb_init(TestOneof, allocator);
    }
    pub fn deinit(self: TestOneof) void {
        return pb_deinit(self);
    }
};

pub const TestOneofBackwardsCompatible = struct {
    foo_int: ?i32,
    foo_string: ?[]const u8,
    foo_message: ?TestAllTypes,
    a: ?i32,
    b: ?[]const u8,

    pub const _desc_table = .{
        .foo_int = fd(1, .{ .Varint = .Simple }),
        .foo_string = fd(2, .String),
        .foo_message = fd(3, .{ .SubMessage = {} }),
        .a = fd(5, .{ .Varint = .Simple }),
        .b = fd(6, .String),
    };


    pub fn encode(self: TestOneofBackwardsCompatible, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestOneofBackwardsCompatible {
        return pb_decode(TestOneofBackwardsCompatible, input, allocator);
    }
    pub fn init(allocator: Allocator) TestOneofBackwardsCompatible {
        return pb_init(TestOneofBackwardsCompatible, allocator);
    }
    pub fn deinit(self: TestOneofBackwardsCompatible) void {
        return pb_deinit(self);
    }
};

pub const TestOneof2 = struct {
    foo_int: ?i32,
    foo_string: ?[]const u8,
    foo_cord: ?[]const u8,
    foo_string_piece: ?[]const u8,
    foo_bytes: ?[]const u8,
    foo_enum: ?NestedEnum,
    foo_message: ?NestedMessage,
    a: ?i32,
    b: ?[]const u8,
    foo_lazy_message: ?NestedMessage,
    bar_int: ?i32,
    bar_string: ?[]const u8,
    bar_cord: ?[]const u8,
    bar_string_piece: ?[]const u8,
    bar_bytes: ?[]const u8,
    bar_enum: ?NestedEnum,
    bar_string_with_empty_default: ?[]const u8,
    bar_cord_with_empty_default: ?[]const u8,
    bar_string_piece_with_empty_default: ?[]const u8,
    bar_bytes_with_empty_default: ?[]const u8,
    baz_int: ?i32,
    baz_string: ?[]const u8,

    pub const _desc_table = .{
        .foo_int = fd(1, .{ .Varint = .Simple }),
        .foo_string = fd(2, .String),
        .foo_cord = fd(3, .String),
        .foo_string_piece = fd(4, .String),
        .foo_bytes = fd(5, .String),
        .foo_enum = fd(6, .{ .Varint = .Simple }),
        .foo_message = fd(7, .{ .SubMessage = {} }),
        .a = fd(9, .{ .Varint = .Simple }),
        .b = fd(10, .String),
        .foo_lazy_message = fd(11, .{ .SubMessage = {} }),
        .bar_int = fd(12, .{ .Varint = .Simple }),
        .bar_string = fd(13, .String),
        .bar_cord = fd(14, .String),
        .bar_string_piece = fd(15, .String),
        .bar_bytes = fd(16, .String),
        .bar_enum = fd(17, .{ .Varint = .Simple }),
        .bar_string_with_empty_default = fd(20, .String),
        .bar_cord_with_empty_default = fd(21, .String),
        .bar_string_piece_with_empty_default = fd(22, .String),
        .bar_bytes_with_empty_default = fd(23, .String),
        .baz_int = fd(18, .{ .Varint = .Simple }),
        .baz_string = fd(19, .String),
    };

pub const NestedEnum = enum(i32) {
   FOO = 1,
   BAR = 2,
   BAZ = 3,
    _,
};


pub const NestedMessage = struct {
    moo_int: ?i64,
    corge_int: ArrayList(i32),

    pub const _desc_table = .{
        .moo_int = fd(1, .{ .Varint = .Simple }),
        .corge_int = fd(2, .{ .List = .{ .Varint = .Simple }}),
    };


    pub fn encode(self: NestedMessage, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !NestedMessage {
        return pb_decode(NestedMessage, input, allocator);
    }
    pub fn init(allocator: Allocator) NestedMessage {
        return pb_init(NestedMessage, allocator);
    }
    pub fn deinit(self: NestedMessage) void {
        return pb_deinit(self);
    }
};


    pub fn encode(self: TestOneof2, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestOneof2 {
        return pb_decode(TestOneof2, input, allocator);
    }
    pub fn init(allocator: Allocator) TestOneof2 {
        return pb_init(TestOneof2, allocator);
    }
    pub fn deinit(self: TestOneof2) void {
        return pb_deinit(self);
    }
};

pub const TestRequiredOneof = struct {
    foo_int: ?i32,
    foo_string: ?[]const u8,
    foo_message: ?NestedMessage,

    pub const _desc_table = .{
        .foo_int = fd(1, .{ .Varint = .Simple }),
        .foo_string = fd(2, .String),
        .foo_message = fd(3, .{ .SubMessage = {} }),
    };

pub const NestedMessage = struct {
    required_double: f64,

    pub const _desc_table = .{
        .required_double = fd(1, .{ .FixedInt = .I64 }),
    };


    pub fn encode(self: NestedMessage, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !NestedMessage {
        return pb_decode(NestedMessage, input, allocator);
    }
    pub fn init(allocator: Allocator) NestedMessage {
        return pb_init(NestedMessage, allocator);
    }
    pub fn deinit(self: NestedMessage) void {
        return pb_deinit(self);
    }
};


    pub fn encode(self: TestRequiredOneof, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestRequiredOneof {
        return pb_decode(TestRequiredOneof, input, allocator);
    }
    pub fn init(allocator: Allocator) TestRequiredOneof {
        return pb_init(TestRequiredOneof, allocator);
    }
    pub fn deinit(self: TestRequiredOneof) void {
        return pb_deinit(self);
    }
};

pub const TestPackedTypes = struct {
    packed_int32: ArrayList(i32),
    packed_int64: ArrayList(i64),
    packed_uint32: ArrayList(u32),
    packed_uint64: ArrayList(u64),
    packed_sint32: ArrayList(i32),
    packed_sint64: ArrayList(i64),
    packed_fixed32: ArrayList(u32),
    packed_fixed64: ArrayList(u64),
    packed_sfixed32: ArrayList(i32),
    packed_sfixed64: ArrayList(i64),
    packed_float: ArrayList(f32),
    packed_double: ArrayList(f64),
    packed_bool: ArrayList(bool),
    packed_enum: ArrayList(ForeignEnum),

    pub const _desc_table = .{
        .packed_int32 = fd(90, .{ .PackedList = .{ .Varint = .Simple }}),
        .packed_int64 = fd(91, .{ .PackedList = .{ .Varint = .Simple }}),
        .packed_uint32 = fd(92, .{ .PackedList = .{ .Varint = .Simple }}),
        .packed_uint64 = fd(93, .{ .PackedList = .{ .Varint = .Simple }}),
        .packed_sint32 = fd(94, .{ .PackedList = .{ .Varint = .ZigZagOptimized }}),
        .packed_sint64 = fd(95, .{ .PackedList = .{ .Varint = .ZigZagOptimized }}),
        .packed_fixed32 = fd(96, .{ .PackedList = .{ .FixedInt = .I32 }}),
        .packed_fixed64 = fd(97, .{ .PackedList = .{ .FixedInt = .I64 }}),
        .packed_sfixed32 = fd(98, .{ .PackedList = .{ .FixedInt = .I32 }}),
        .packed_sfixed64 = fd(99, .{ .PackedList = .{ .FixedInt = .I64 }}),
        .packed_float = fd(100, .{ .PackedList = .{ .FixedInt = .I32 }}),
        .packed_double = fd(101, .{ .PackedList = .{ .FixedInt = .I64 }}),
        .packed_bool = fd(102, .{ .PackedList = .{ .Varint = .Simple }}),
        .packed_enum = fd(103, .{ .PackedList = .{ .Varint = .Simple }}),
    };


    pub fn encode(self: TestPackedTypes, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestPackedTypes {
        return pb_decode(TestPackedTypes, input, allocator);
    }
    pub fn init(allocator: Allocator) TestPackedTypes {
        return pb_init(TestPackedTypes, allocator);
    }
    pub fn deinit(self: TestPackedTypes) void {
        return pb_deinit(self);
    }
};

pub const TestUnpackedTypes = struct {
    unpacked_int32: ArrayList(i32),
    unpacked_int64: ArrayList(i64),
    unpacked_uint32: ArrayList(u32),
    unpacked_uint64: ArrayList(u64),
    unpacked_sint32: ArrayList(i32),
    unpacked_sint64: ArrayList(i64),
    unpacked_fixed32: ArrayList(u32),
    unpacked_fixed64: ArrayList(u64),
    unpacked_sfixed32: ArrayList(i32),
    unpacked_sfixed64: ArrayList(i64),
    unpacked_float: ArrayList(f32),
    unpacked_double: ArrayList(f64),
    unpacked_bool: ArrayList(bool),
    unpacked_enum: ArrayList(ForeignEnum),

    pub const _desc_table = .{
        .unpacked_int32 = fd(90, .{ .List = .{ .Varint = .Simple }}),
        .unpacked_int64 = fd(91, .{ .List = .{ .Varint = .Simple }}),
        .unpacked_uint32 = fd(92, .{ .List = .{ .Varint = .Simple }}),
        .unpacked_uint64 = fd(93, .{ .List = .{ .Varint = .Simple }}),
        .unpacked_sint32 = fd(94, .{ .List = .{ .Varint = .ZigZagOptimized }}),
        .unpacked_sint64 = fd(95, .{ .List = .{ .Varint = .ZigZagOptimized }}),
        .unpacked_fixed32 = fd(96, .{ .List = .{ .FixedInt = .I32 }}),
        .unpacked_fixed64 = fd(97, .{ .List = .{ .FixedInt = .I64 }}),
        .unpacked_sfixed32 = fd(98, .{ .List = .{ .FixedInt = .I32 }}),
        .unpacked_sfixed64 = fd(99, .{ .List = .{ .FixedInt = .I64 }}),
        .unpacked_float = fd(100, .{ .List = .{ .FixedInt = .I32 }}),
        .unpacked_double = fd(101, .{ .List = .{ .FixedInt = .I64 }}),
        .unpacked_bool = fd(102, .{ .List = .{ .Varint = .Simple }}),
        .unpacked_enum = fd(103, .{ .List = .{ .Varint = .Simple }}),
    };


    pub fn encode(self: TestUnpackedTypes, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestUnpackedTypes {
        return pb_decode(TestUnpackedTypes, input, allocator);
    }
    pub fn init(allocator: Allocator) TestUnpackedTypes {
        return pb_init(TestUnpackedTypes, allocator);
    }
    pub fn deinit(self: TestUnpackedTypes) void {
        return pb_deinit(self);
    }
};

pub const TestPackedExtensions = struct {

    pub const _desc_table = .{
    };


    pub fn encode(self: TestPackedExtensions, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestPackedExtensions {
        return pb_decode(TestPackedExtensions, input, allocator);
    }
    pub fn init(allocator: Allocator) TestPackedExtensions {
        return pb_init(TestPackedExtensions, allocator);
    }
    pub fn deinit(self: TestPackedExtensions) void {
        return pb_deinit(self);
    }
};

pub const TestUnpackedExtensions = struct {

    pub const _desc_table = .{
    };


    pub fn encode(self: TestUnpackedExtensions, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestUnpackedExtensions {
        return pb_decode(TestUnpackedExtensions, input, allocator);
    }
    pub fn init(allocator: Allocator) TestUnpackedExtensions {
        return pb_init(TestUnpackedExtensions, allocator);
    }
    pub fn deinit(self: TestUnpackedExtensions) void {
        return pb_deinit(self);
    }
};

pub const TestDynamicExtensions = struct {
    scalar_extension: ?u32,
    enum_extension: ?ForeignEnum,
    dynamic_enum_extension: ?DynamicEnumType,
    message_extension: ?ForeignMessage,
    dynamic_message_extension: ?DynamicMessageType,
    repeated_extension: ArrayList([]const u8),
    packed_extension: ArrayList(i32),

    pub const _desc_table = .{
        .scalar_extension = fd(2000, .{ .FixedInt = .I32 }),
        .enum_extension = fd(2001, .{ .Varint = .Simple }),
        .dynamic_enum_extension = fd(2002, .{ .Varint = .Simple }),
        .message_extension = fd(2003, .{ .SubMessage = {} }),
        .dynamic_message_extension = fd(2004, .{ .SubMessage = {} }),
        .repeated_extension = fd(2005, .{ .List = .String}),
        .packed_extension = fd(2006, .{ .PackedList = .{ .Varint = .ZigZagOptimized }}),
    };

pub const DynamicEnumType = enum(i32) {
   DYNAMIC_FOO = 2200,
   DYNAMIC_BAR = 2201,
   DYNAMIC_BAZ = 2202,
    _,
};


pub const DynamicMessageType = struct {
    dynamic_field: ?i32,

    pub const _desc_table = .{
        .dynamic_field = fd(2100, .{ .Varint = .Simple }),
    };


    pub fn encode(self: DynamicMessageType, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !DynamicMessageType {
        return pb_decode(DynamicMessageType, input, allocator);
    }
    pub fn init(allocator: Allocator) DynamicMessageType {
        return pb_init(DynamicMessageType, allocator);
    }
    pub fn deinit(self: DynamicMessageType) void {
        return pb_deinit(self);
    }
};


    pub fn encode(self: TestDynamicExtensions, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestDynamicExtensions {
        return pb_decode(TestDynamicExtensions, input, allocator);
    }
    pub fn init(allocator: Allocator) TestDynamicExtensions {
        return pb_init(TestDynamicExtensions, allocator);
    }
    pub fn deinit(self: TestDynamicExtensions) void {
        return pb_deinit(self);
    }
};

pub const TestRepeatedScalarDifferentTagSizes = struct {
    repeated_fixed32: ArrayList(u32),
    repeated_int32: ArrayList(i32),
    repeated_fixed64: ArrayList(u64),
    repeated_int64: ArrayList(i64),
    repeated_float: ArrayList(f32),
    repeated_uint64: ArrayList(u64),

    pub const _desc_table = .{
        .repeated_fixed32 = fd(12, .{ .List = .{ .FixedInt = .I32 }}),
        .repeated_int32 = fd(13, .{ .List = .{ .Varint = .Simple }}),
        .repeated_fixed64 = fd(2046, .{ .List = .{ .FixedInt = .I64 }}),
        .repeated_int64 = fd(2047, .{ .List = .{ .Varint = .Simple }}),
        .repeated_float = fd(262142, .{ .List = .{ .FixedInt = .I32 }}),
        .repeated_uint64 = fd(262143, .{ .List = .{ .Varint = .Simple }}),
    };


    pub fn encode(self: TestRepeatedScalarDifferentTagSizes, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestRepeatedScalarDifferentTagSizes {
        return pb_decode(TestRepeatedScalarDifferentTagSizes, input, allocator);
    }
    pub fn init(allocator: Allocator) TestRepeatedScalarDifferentTagSizes {
        return pb_init(TestRepeatedScalarDifferentTagSizes, allocator);
    }
    pub fn deinit(self: TestRepeatedScalarDifferentTagSizes) void {
        return pb_deinit(self);
    }
};

pub const TestParsingMerge = struct {
    required_all_types: ?TestAllTypes,
    optional_all_types: ?TestAllTypes,
    repeated_all_types: ArrayList(TestAllTypes),
    optional_group_all_types: ?TestAllTypes,
    repeated_group_all_types: ?TestAllTypes,

    pub const _desc_table = .{
        .required_all_types = fd(1, .{ .SubMessage = {} }),
        .optional_all_types = fd(2, .{ .SubMessage = {} }),
        .repeated_all_types = fd(3, .{ .List = .{ .SubMessage = {} }}),
        .optional_group_all_types = fd(11, .{ .SubMessage = {} }),
        .repeated_group_all_types = fd(21, .{ .SubMessage = {} }),
    };

pub const RepeatedFieldsGenerator = struct {
    field1: ArrayList(TestAllTypes),
    field2: ArrayList(TestAllTypes),
    field3: ArrayList(TestAllTypes),
    Group1_field1: ?TestAllTypes,
    Group2_field1: ?TestAllTypes,
    ext1: ArrayList(TestAllTypes),
    ext2: ArrayList(TestAllTypes),

    pub const _desc_table = .{
        .field1 = fd(1, .{ .List = .{ .SubMessage = {} }}),
        .field2 = fd(2, .{ .List = .{ .SubMessage = {} }}),
        .field3 = fd(3, .{ .List = .{ .SubMessage = {} }}),
        .Group1_field1 = fd(11, .{ .SubMessage = {} }),
        .Group2_field1 = fd(21, .{ .SubMessage = {} }),
        .ext1 = fd(1000, .{ .List = .{ .SubMessage = {} }}),
        .ext2 = fd(1001, .{ .List = .{ .SubMessage = {} }}),
    };


    pub fn encode(self: RepeatedFieldsGenerator, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !RepeatedFieldsGenerator {
        return pb_decode(RepeatedFieldsGenerator, input, allocator);
    }
    pub fn init(allocator: Allocator) RepeatedFieldsGenerator {
        return pb_init(RepeatedFieldsGenerator, allocator);
    }
    pub fn deinit(self: RepeatedFieldsGenerator) void {
        return pb_deinit(self);
    }
};


    pub fn encode(self: TestParsingMerge, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestParsingMerge {
        return pb_decode(TestParsingMerge, input, allocator);
    }
    pub fn init(allocator: Allocator) TestParsingMerge {
        return pb_init(TestParsingMerge, allocator);
    }
    pub fn deinit(self: TestParsingMerge) void {
        return pb_deinit(self);
    }
};

pub const TestMergeException = struct {
    all_extensions: ?TestAllExtensions,

    pub const _desc_table = .{
        .all_extensions = fd(1, .{ .SubMessage = {} }),
    };


    pub fn encode(self: TestMergeException, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestMergeException {
        return pb_decode(TestMergeException, input, allocator);
    }
    pub fn init(allocator: Allocator) TestMergeException {
        return pb_init(TestMergeException, allocator);
    }
    pub fn deinit(self: TestMergeException) void {
        return pb_deinit(self);
    }
};

pub const TestCommentInjectionMessage = struct {
    a: ?[]const u8,

    pub const _desc_table = .{
        .a = fd(1, .String),
    };


    pub fn encode(self: TestCommentInjectionMessage, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestCommentInjectionMessage {
        return pb_decode(TestCommentInjectionMessage, input, allocator);
    }
    pub fn init(allocator: Allocator) TestCommentInjectionMessage {
        return pb_init(TestCommentInjectionMessage, allocator);
    }
    pub fn deinit(self: TestCommentInjectionMessage) void {
        return pb_deinit(self);
    }
};

pub const TestMessageSize = struct {
    m1: ?bool,
    m2: ?i64,
    m3: ?bool,
    m4: ?[]const u8,
    m5: ?i32,
    m6: ?i64,

    pub const _desc_table = .{
        .m1 = fd(1, .{ .Varint = .Simple }),
        .m2 = fd(2, .{ .Varint = .Simple }),
        .m3 = fd(3, .{ .Varint = .Simple }),
        .m4 = fd(4, .String),
        .m5 = fd(5, .{ .Varint = .Simple }),
        .m6 = fd(6, .{ .Varint = .Simple }),
    };


    pub fn encode(self: TestMessageSize, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestMessageSize {
        return pb_decode(TestMessageSize, input, allocator);
    }
    pub fn init(allocator: Allocator) TestMessageSize {
        return pb_init(TestMessageSize, allocator);
    }
    pub fn deinit(self: TestMessageSize) void {
        return pb_deinit(self);
    }
};

pub const FooRequest = struct {

    pub const _desc_table = .{
    };


    pub fn encode(self: FooRequest, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !FooRequest {
        return pb_decode(FooRequest, input, allocator);
    }
    pub fn init(allocator: Allocator) FooRequest {
        return pb_init(FooRequest, allocator);
    }
    pub fn deinit(self: FooRequest) void {
        return pb_deinit(self);
    }
};

pub const FooResponse = struct {

    pub const _desc_table = .{
    };


    pub fn encode(self: FooResponse, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !FooResponse {
        return pb_decode(FooResponse, input, allocator);
    }
    pub fn init(allocator: Allocator) FooResponse {
        return pb_init(FooResponse, allocator);
    }
    pub fn deinit(self: FooResponse) void {
        return pb_deinit(self);
    }
};

pub const FooClientMessage = struct {

    pub const _desc_table = .{
    };


    pub fn encode(self: FooClientMessage, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !FooClientMessage {
        return pb_decode(FooClientMessage, input, allocator);
    }
    pub fn init(allocator: Allocator) FooClientMessage {
        return pb_init(FooClientMessage, allocator);
    }
    pub fn deinit(self: FooClientMessage) void {
        return pb_deinit(self);
    }
};

pub const FooServerMessage = struct {

    pub const _desc_table = .{
    };


    pub fn encode(self: FooServerMessage, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !FooServerMessage {
        return pb_decode(FooServerMessage, input, allocator);
    }
    pub fn init(allocator: Allocator) FooServerMessage {
        return pb_init(FooServerMessage, allocator);
    }
    pub fn deinit(self: FooServerMessage) void {
        return pb_deinit(self);
    }
};

pub const BarRequest = struct {

    pub const _desc_table = .{
    };


    pub fn encode(self: BarRequest, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !BarRequest {
        return pb_decode(BarRequest, input, allocator);
    }
    pub fn init(allocator: Allocator) BarRequest {
        return pb_init(BarRequest, allocator);
    }
    pub fn deinit(self: BarRequest) void {
        return pb_deinit(self);
    }
};

pub const BarResponse = struct {

    pub const _desc_table = .{
    };


    pub fn encode(self: BarResponse, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !BarResponse {
        return pb_decode(BarResponse, input, allocator);
    }
    pub fn init(allocator: Allocator) BarResponse {
        return pb_init(BarResponse, allocator);
    }
    pub fn deinit(self: BarResponse) void {
        return pb_deinit(self);
    }
};

pub const TestJsonName = struct {
    field_name1: ?i32,
    fieldName2: ?i32,
    FieldName3: ?i32,
    _field_name4: ?i32,
    FIELD_NAME5: ?i32,
    field_name6: ?i32,
    fieldname7: ?i32,

    pub const _desc_table = .{
        .field_name1 = fd(1, .{ .Varint = .Simple }),
        .fieldName2 = fd(2, .{ .Varint = .Simple }),
        .FieldName3 = fd(3, .{ .Varint = .Simple }),
        ._field_name4 = fd(4, .{ .Varint = .Simple }),
        .FIELD_NAME5 = fd(5, .{ .Varint = .Simple }),
        .field_name6 = fd(6, .{ .Varint = .Simple }),
        .fieldname7 = fd(7, .{ .Varint = .Simple }),
    };


    pub fn encode(self: TestJsonName, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestJsonName {
        return pb_decode(TestJsonName, input, allocator);
    }
    pub fn init(allocator: Allocator) TestJsonName {
        return pb_init(TestJsonName, allocator);
    }
    pub fn deinit(self: TestJsonName) void {
        return pb_deinit(self);
    }
};

pub const TestHugeFieldNumbers = struct {
    optional_int32: ?i32,
    fixed_32: ?i32,
    repeated_int32: ArrayList(i32),
    packed_int32: ArrayList(i32),
    optional_enum: ?ForeignEnum,
    optional_string: ?[]const u8,
    optional_bytes: ?[]const u8,
    optional_message: ?ForeignMessage,
    group_a: ?i32,
    string_string_map: ArrayList(StringStringMapEntry),
    oneof_uint32: ?u32,
    oneof_test_all_types: ?TestAllTypes,
    oneof_string: ?[]const u8,
    oneof_bytes: ?[]const u8,

    pub const _desc_table = .{
        .optional_int32 = fd(536870000, .{ .Varint = .Simple }),
        .fixed_32 = fd(536870001, .{ .Varint = .Simple }),
        .repeated_int32 = fd(536870002, .{ .List = .{ .Varint = .Simple }}),
        .packed_int32 = fd(536870003, .{ .PackedList = .{ .Varint = .Simple }}),
        .optional_enum = fd(536870004, .{ .Varint = .Simple }),
        .optional_string = fd(536870005, .String),
        .optional_bytes = fd(536870006, .String),
        .optional_message = fd(536870007, .{ .SubMessage = {} }),
        .group_a = fd(536870009, .{ .Varint = .Simple }),
        .string_string_map = fd(536870010, .{ .List = .{ .SubMessage = {} }}),
        .oneof_uint32 = fd(536870011, .{ .Varint = .Simple }),
        .oneof_test_all_types = fd(536870012, .{ .SubMessage = {} }),
        .oneof_string = fd(536870013, .String),
        .oneof_bytes = fd(536870014, .String),
    };

pub const StringStringMapEntry = struct {
    key: ?[]const u8,
    value: ?[]const u8,

    pub const _desc_table = .{
        .key = fd(1, .String),
        .value = fd(2, .String),
    };


    pub fn encode(self: StringStringMapEntry, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !StringStringMapEntry {
        return pb_decode(StringStringMapEntry, input, allocator);
    }
    pub fn init(allocator: Allocator) StringStringMapEntry {
        return pb_init(StringStringMapEntry, allocator);
    }
    pub fn deinit(self: StringStringMapEntry) void {
        return pb_deinit(self);
    }
};


    pub fn encode(self: TestHugeFieldNumbers, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestHugeFieldNumbers {
        return pb_decode(TestHugeFieldNumbers, input, allocator);
    }
    pub fn init(allocator: Allocator) TestHugeFieldNumbers {
        return pb_init(TestHugeFieldNumbers, allocator);
    }
    pub fn deinit(self: TestHugeFieldNumbers) void {
        return pb_deinit(self);
    }
};

pub const TestExtensionInsideTable = struct {
    field1: ?i32,
    field2: ?i32,
    field3: ?i32,
    field4: ?i32,
    field6: ?i32,
    field7: ?i32,
    field8: ?i32,
    field9: ?i32,
    field10: ?i32,

    pub const _desc_table = .{
        .field1 = fd(1, .{ .Varint = .Simple }),
        .field2 = fd(2, .{ .Varint = .Simple }),
        .field3 = fd(3, .{ .Varint = .Simple }),
        .field4 = fd(4, .{ .Varint = .Simple }),
        .field6 = fd(6, .{ .Varint = .Simple }),
        .field7 = fd(7, .{ .Varint = .Simple }),
        .field8 = fd(8, .{ .Varint = .Simple }),
        .field9 = fd(9, .{ .Varint = .Simple }),
        .field10 = fd(10, .{ .Varint = .Simple }),
    };


    pub fn encode(self: TestExtensionInsideTable, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestExtensionInsideTable {
        return pb_decode(TestExtensionInsideTable, input, allocator);
    }
    pub fn init(allocator: Allocator) TestExtensionInsideTable {
        return pb_init(TestExtensionInsideTable, allocator);
    }
    pub fn deinit(self: TestExtensionInsideTable) void {
        return pb_deinit(self);
    }
};

pub const TestNestedGroupExtensionInnerExtension = struct {
    inner_name: ?[]const u8,

    pub const _desc_table = .{
        .inner_name = fd(1, .String),
    };


    pub fn encode(self: TestNestedGroupExtensionInnerExtension, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestNestedGroupExtensionInnerExtension {
        return pb_decode(TestNestedGroupExtensionInnerExtension, input, allocator);
    }
    pub fn init(allocator: Allocator) TestNestedGroupExtensionInnerExtension {
        return pb_init(TestNestedGroupExtensionInnerExtension, allocator);
    }
    pub fn deinit(self: TestNestedGroupExtensionInnerExtension) void {
        return pb_deinit(self);
    }
};

pub const TestExtensionRangeSerialize = struct {
    foo_one: ?i32,
    foo_two: ?i32,
    foo_three: ?i32,
    foo_four: ?i32,

    pub const _desc_table = .{
        .foo_one = fd(1, .{ .Varint = .Simple }),
        .foo_two = fd(6, .{ .Varint = .Simple }),
        .foo_three = fd(7, .{ .Varint = .Simple }),
        .foo_four = fd(13, .{ .Varint = .Simple }),
    };


    pub fn encode(self: TestExtensionRangeSerialize, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestExtensionRangeSerialize {
        return pb_decode(TestExtensionRangeSerialize, input, allocator);
    }
    pub fn init(allocator: Allocator) TestExtensionRangeSerialize {
        return pb_init(TestExtensionRangeSerialize, allocator);
    }
    pub fn deinit(self: TestExtensionRangeSerialize) void {
        return pb_deinit(self);
    }
};

pub const TestVerifyInt32Simple = struct {
    optional_int32_1: ?i32,
    optional_int32_2: ?i32,
    optional_int32_63: ?i32,
    optional_int32_64: ?i32,

    pub const _desc_table = .{
        .optional_int32_1 = fd(1, .{ .Varint = .Simple }),
        .optional_int32_2 = fd(2, .{ .Varint = .Simple }),
        .optional_int32_63 = fd(63, .{ .Varint = .Simple }),
        .optional_int32_64 = fd(64, .{ .Varint = .Simple }),
    };


    pub fn encode(self: TestVerifyInt32Simple, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestVerifyInt32Simple {
        return pb_decode(TestVerifyInt32Simple, input, allocator);
    }
    pub fn init(allocator: Allocator) TestVerifyInt32Simple {
        return pb_init(TestVerifyInt32Simple, allocator);
    }
    pub fn deinit(self: TestVerifyInt32Simple) void {
        return pb_deinit(self);
    }
};

pub const TestVerifyInt32 = struct {
    optional_int32_1: ?i32,
    optional_int32_2: ?i32,
    optional_int32_63: ?i32,
    optional_int32_64: ?i32,
    optional_all_types: ?TestAllTypes,
    repeated_all_types: ArrayList(TestAllTypes),

    pub const _desc_table = .{
        .optional_int32_1 = fd(1, .{ .Varint = .Simple }),
        .optional_int32_2 = fd(2, .{ .Varint = .Simple }),
        .optional_int32_63 = fd(63, .{ .Varint = .Simple }),
        .optional_int32_64 = fd(64, .{ .Varint = .Simple }),
        .optional_all_types = fd(9, .{ .SubMessage = {} }),
        .repeated_all_types = fd(10, .{ .List = .{ .SubMessage = {} }}),
    };


    pub fn encode(self: TestVerifyInt32, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestVerifyInt32 {
        return pb_decode(TestVerifyInt32, input, allocator);
    }
    pub fn init(allocator: Allocator) TestVerifyInt32 {
        return pb_init(TestVerifyInt32, allocator);
    }
    pub fn deinit(self: TestVerifyInt32) void {
        return pb_deinit(self);
    }
};

pub const TestVerifyMostlyInt32 = struct {
    optional_int64_30: ?i64,
    optional_int32_1: ?i32,
    optional_int32_2: ?i32,
    optional_int32_3: ?i32,
    optional_int32_4: ?i32,
    optional_int32_63: ?i32,
    optional_int32_64: ?i32,
    optional_all_types: ?TestAllTypes,
    repeated_all_types: ArrayList(TestAllTypes),

    pub const _desc_table = .{
        .optional_int64_30 = fd(30, .{ .Varint = .Simple }),
        .optional_int32_1 = fd(1, .{ .Varint = .Simple }),
        .optional_int32_2 = fd(2, .{ .Varint = .Simple }),
        .optional_int32_3 = fd(3, .{ .Varint = .Simple }),
        .optional_int32_4 = fd(4, .{ .Varint = .Simple }),
        .optional_int32_63 = fd(63, .{ .Varint = .Simple }),
        .optional_int32_64 = fd(64, .{ .Varint = .Simple }),
        .optional_all_types = fd(9, .{ .SubMessage = {} }),
        .repeated_all_types = fd(10, .{ .List = .{ .SubMessage = {} }}),
    };


    pub fn encode(self: TestVerifyMostlyInt32, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestVerifyMostlyInt32 {
        return pb_decode(TestVerifyMostlyInt32, input, allocator);
    }
    pub fn init(allocator: Allocator) TestVerifyMostlyInt32 {
        return pb_init(TestVerifyMostlyInt32, allocator);
    }
    pub fn deinit(self: TestVerifyMostlyInt32) void {
        return pb_deinit(self);
    }
};

pub const TestVerifyMostlyInt32BigFieldNumber = struct {
    optional_int64_30: ?i64,
    optional_int32_300: ?i32,
    optional_int32_1: ?i32,
    optional_int32_2: ?i32,
    optional_int32_3: ?i32,
    optional_int32_4: ?i32,
    optional_int32_63: ?i32,
    optional_int32_64: ?i32,
    optional_all_types: ?TestAllTypes,
    repeated_all_types: ArrayList(TestAllTypes),

    pub const _desc_table = .{
        .optional_int64_30 = fd(30, .{ .Varint = .Simple }),
        .optional_int32_300 = fd(300, .{ .Varint = .Simple }),
        .optional_int32_1 = fd(1, .{ .Varint = .Simple }),
        .optional_int32_2 = fd(2, .{ .Varint = .Simple }),
        .optional_int32_3 = fd(3, .{ .Varint = .Simple }),
        .optional_int32_4 = fd(4, .{ .Varint = .Simple }),
        .optional_int32_63 = fd(63, .{ .Varint = .Simple }),
        .optional_int32_64 = fd(64, .{ .Varint = .Simple }),
        .optional_all_types = fd(9, .{ .SubMessage = {} }),
        .repeated_all_types = fd(10, .{ .List = .{ .SubMessage = {} }}),
    };


    pub fn encode(self: TestVerifyMostlyInt32BigFieldNumber, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestVerifyMostlyInt32BigFieldNumber {
        return pb_decode(TestVerifyMostlyInt32BigFieldNumber, input, allocator);
    }
    pub fn init(allocator: Allocator) TestVerifyMostlyInt32BigFieldNumber {
        return pb_init(TestVerifyMostlyInt32BigFieldNumber, allocator);
    }
    pub fn deinit(self: TestVerifyMostlyInt32BigFieldNumber) void {
        return pb_deinit(self);
    }
};

pub const TestVerifyUint32Simple = struct {
    optional_uint32_1: ?u32,
    optional_uint32_2: ?u32,
    optional_uint32_63: ?u32,
    optional_uint32_64: ?u32,

    pub const _desc_table = .{
        .optional_uint32_1 = fd(1, .{ .Varint = .Simple }),
        .optional_uint32_2 = fd(2, .{ .Varint = .Simple }),
        .optional_uint32_63 = fd(63, .{ .Varint = .Simple }),
        .optional_uint32_64 = fd(64, .{ .Varint = .Simple }),
    };


    pub fn encode(self: TestVerifyUint32Simple, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestVerifyUint32Simple {
        return pb_decode(TestVerifyUint32Simple, input, allocator);
    }
    pub fn init(allocator: Allocator) TestVerifyUint32Simple {
        return pb_init(TestVerifyUint32Simple, allocator);
    }
    pub fn deinit(self: TestVerifyUint32Simple) void {
        return pb_deinit(self);
    }
};

pub const TestVerifyUint32 = struct {
    optional_uint32_1: ?u32,
    optional_uint32_2: ?u32,
    optional_uint32_63: ?u32,
    optional_uint32_64: ?u32,
    optional_all_types: ?TestAllTypes,
    repeated_all_types: ArrayList(TestAllTypes),

    pub const _desc_table = .{
        .optional_uint32_1 = fd(1, .{ .Varint = .Simple }),
        .optional_uint32_2 = fd(2, .{ .Varint = .Simple }),
        .optional_uint32_63 = fd(63, .{ .Varint = .Simple }),
        .optional_uint32_64 = fd(64, .{ .Varint = .Simple }),
        .optional_all_types = fd(9, .{ .SubMessage = {} }),
        .repeated_all_types = fd(10, .{ .List = .{ .SubMessage = {} }}),
    };


    pub fn encode(self: TestVerifyUint32, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestVerifyUint32 {
        return pb_decode(TestVerifyUint32, input, allocator);
    }
    pub fn init(allocator: Allocator) TestVerifyUint32 {
        return pb_init(TestVerifyUint32, allocator);
    }
    pub fn deinit(self: TestVerifyUint32) void {
        return pb_deinit(self);
    }
};

pub const TestVerifyOneUint32 = struct {
    optional_uint32_1: ?u32,
    optional_int32_2: ?i32,
    optional_int32_63: ?i32,
    optional_int32_64: ?i32,
    optional_all_types: ?TestAllTypes,
    repeated_all_types: ArrayList(TestAllTypes),

    pub const _desc_table = .{
        .optional_uint32_1 = fd(1, .{ .Varint = .Simple }),
        .optional_int32_2 = fd(2, .{ .Varint = .Simple }),
        .optional_int32_63 = fd(63, .{ .Varint = .Simple }),
        .optional_int32_64 = fd(64, .{ .Varint = .Simple }),
        .optional_all_types = fd(9, .{ .SubMessage = {} }),
        .repeated_all_types = fd(10, .{ .List = .{ .SubMessage = {} }}),
    };


    pub fn encode(self: TestVerifyOneUint32, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestVerifyOneUint32 {
        return pb_decode(TestVerifyOneUint32, input, allocator);
    }
    pub fn init(allocator: Allocator) TestVerifyOneUint32 {
        return pb_init(TestVerifyOneUint32, allocator);
    }
    pub fn deinit(self: TestVerifyOneUint32) void {
        return pb_deinit(self);
    }
};

pub const TestVerifyOneInt32BigFieldNumber = struct {
    optional_int32_65: ?i32,
    optional_int64_1: ?i64,
    optional_int64_2: ?i64,
    optional_int64_63: ?i64,
    optional_int64_64: ?i64,
    optional_all_types: ?TestAllTypes,
    repeated_all_types: ArrayList(TestAllTypes),

    pub const _desc_table = .{
        .optional_int32_65 = fd(65, .{ .Varint = .Simple }),
        .optional_int64_1 = fd(1, .{ .Varint = .Simple }),
        .optional_int64_2 = fd(2, .{ .Varint = .Simple }),
        .optional_int64_63 = fd(63, .{ .Varint = .Simple }),
        .optional_int64_64 = fd(64, .{ .Varint = .Simple }),
        .optional_all_types = fd(9, .{ .SubMessage = {} }),
        .repeated_all_types = fd(10, .{ .List = .{ .SubMessage = {} }}),
    };


    pub fn encode(self: TestVerifyOneInt32BigFieldNumber, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestVerifyOneInt32BigFieldNumber {
        return pb_decode(TestVerifyOneInt32BigFieldNumber, input, allocator);
    }
    pub fn init(allocator: Allocator) TestVerifyOneInt32BigFieldNumber {
        return pb_init(TestVerifyOneInt32BigFieldNumber, allocator);
    }
    pub fn deinit(self: TestVerifyOneInt32BigFieldNumber) void {
        return pb_deinit(self);
    }
};

pub const TestVerifyInt32BigFieldNumber = struct {
    optional_int32_1000: ?i32,
    optional_int32_65: ?i32,
    optional_int32_1: ?i32,
    optional_int32_2: ?i32,
    optional_int32_63: ?i32,
    optional_int32_64: ?i32,
    optional_all_types: ?TestAllTypes,
    repeated_all_types: ArrayList(TestAllTypes),

    pub const _desc_table = .{
        .optional_int32_1000 = fd(1000, .{ .Varint = .Simple }),
        .optional_int32_65 = fd(65, .{ .Varint = .Simple }),
        .optional_int32_1 = fd(1, .{ .Varint = .Simple }),
        .optional_int32_2 = fd(2, .{ .Varint = .Simple }),
        .optional_int32_63 = fd(63, .{ .Varint = .Simple }),
        .optional_int32_64 = fd(64, .{ .Varint = .Simple }),
        .optional_all_types = fd(9, .{ .SubMessage = {} }),
        .repeated_all_types = fd(10, .{ .List = .{ .SubMessage = {} }}),
    };


    pub fn encode(self: TestVerifyInt32BigFieldNumber, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestVerifyInt32BigFieldNumber {
        return pb_decode(TestVerifyInt32BigFieldNumber, input, allocator);
    }
    pub fn init(allocator: Allocator) TestVerifyInt32BigFieldNumber {
        return pb_init(TestVerifyInt32BigFieldNumber, allocator);
    }
    pub fn deinit(self: TestVerifyInt32BigFieldNumber) void {
        return pb_deinit(self);
    }
};

pub const TestVerifyUint32BigFieldNumber = struct {
    optional_uint32_1000: ?u32,
    optional_uint32_65: ?u32,
    optional_uint32_1: ?u32,
    optional_uint32_2: ?u32,
    optional_uint32_63: ?u32,
    optional_uint32_64: ?u32,
    optional_all_types: ?TestAllTypes,
    repeated_all_types: ArrayList(TestAllTypes),

    pub const _desc_table = .{
        .optional_uint32_1000 = fd(1000, .{ .Varint = .Simple }),
        .optional_uint32_65 = fd(65, .{ .Varint = .Simple }),
        .optional_uint32_1 = fd(1, .{ .Varint = .Simple }),
        .optional_uint32_2 = fd(2, .{ .Varint = .Simple }),
        .optional_uint32_63 = fd(63, .{ .Varint = .Simple }),
        .optional_uint32_64 = fd(64, .{ .Varint = .Simple }),
        .optional_all_types = fd(9, .{ .SubMessage = {} }),
        .repeated_all_types = fd(10, .{ .List = .{ .SubMessage = {} }}),
    };


    pub fn encode(self: TestVerifyUint32BigFieldNumber, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestVerifyUint32BigFieldNumber {
        return pb_decode(TestVerifyUint32BigFieldNumber, input, allocator);
    }
    pub fn init(allocator: Allocator) TestVerifyUint32BigFieldNumber {
        return pb_init(TestVerifyUint32BigFieldNumber, allocator);
    }
    pub fn deinit(self: TestVerifyUint32BigFieldNumber) void {
        return pb_deinit(self);
    }
};

pub const TestVerifyBigFieldNumberUint32 = struct {
    optional_nested: ?Nested,

    pub const _desc_table = .{
        .optional_nested = fd(1, .{ .SubMessage = {} }),
    };

pub const Nested = struct {
    optional_uint32_5000: ?u32,
    optional_uint32_1000: ?u32,
    optional_uint32_66: ?u32,
    optional_uint32_65: ?u32,
    optional_uint32_1: ?u32,
    optional_uint32_2: ?u32,
    optional_uint32_63: ?u32,
    optional_uint32_64: ?u32,
    optional_nested: ?TestVerifyBigFieldNumberUint32.Nested,
    repeated_nested: ArrayList(TestVerifyBigFieldNumberUint32.Nested),

    pub const _desc_table = .{
        .optional_uint32_5000 = fd(5000, .{ .Varint = .Simple }),
        .optional_uint32_1000 = fd(1000, .{ .Varint = .Simple }),
        .optional_uint32_66 = fd(66, .{ .Varint = .Simple }),
        .optional_uint32_65 = fd(65, .{ .Varint = .Simple }),
        .optional_uint32_1 = fd(1, .{ .Varint = .Simple }),
        .optional_uint32_2 = fd(2, .{ .Varint = .Simple }),
        .optional_uint32_63 = fd(63, .{ .Varint = .Simple }),
        .optional_uint32_64 = fd(64, .{ .Varint = .Simple }),
        .optional_nested = fd(9, .{ .SubMessage = {} }),
        .repeated_nested = fd(10, .{ .List = .{ .SubMessage = {} }}),
    };


    pub fn encode(self: Nested, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !Nested {
        return pb_decode(Nested, input, allocator);
    }
    pub fn init(allocator: Allocator) Nested {
        return pb_init(Nested, allocator);
    }
    pub fn deinit(self: Nested) void {
        return pb_deinit(self);
    }
};


    pub fn encode(self: TestVerifyBigFieldNumberUint32, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !TestVerifyBigFieldNumberUint32 {
        return pb_decode(TestVerifyBigFieldNumberUint32, input, allocator);
    }
    pub fn init(allocator: Allocator) TestVerifyBigFieldNumberUint32 {
        return pb_init(TestVerifyBigFieldNumberUint32, allocator);
    }
    pub fn deinit(self: TestVerifyBigFieldNumberUint32) void {
        return pb_deinit(self);
    }
};

pub const EnumParseTester = struct {
    optional_seq_small_0_lowfield: ?SeqSmall0,
    optional_seq_small_0_midfield: ?SeqSmall0,
    optional_seq_small_0_hifield: ?SeqSmall0,
    repeated_seq_small_0_lowfield: ArrayList(SeqSmall0),
    repeated_seq_small_0_midfield: ArrayList(SeqSmall0),
    repeated_seq_small_0_hifield: ArrayList(SeqSmall0),
    packed_seq_small_0_lowfield: ArrayList(SeqSmall0),
    packed_seq_small_0_midfield: ArrayList(SeqSmall0),
    packed_seq_small_0_hifield: ArrayList(SeqSmall0),
    optional_seq_small_1_lowfield: ?SeqSmall1,
    optional_seq_small_1_midfield: ?SeqSmall1,
    optional_seq_small_1_hifield: ?SeqSmall1,
    repeated_seq_small_1_lowfield: ArrayList(SeqSmall1),
    repeated_seq_small_1_midfield: ArrayList(SeqSmall1),
    repeated_seq_small_1_hifield: ArrayList(SeqSmall1),
    packed_seq_small_1_lowfield: ArrayList(SeqSmall1),
    packed_seq_small_1_midfield: ArrayList(SeqSmall1),
    packed_seq_small_1_hifield: ArrayList(SeqSmall1),
    optional_seq_large_lowfield: ?SeqLarge,
    optional_seq_large_midfield: ?SeqLarge,
    optional_seq_large_hifield: ?SeqLarge,
    repeated_seq_large_lowfield: ArrayList(SeqLarge),
    repeated_seq_large_midfield: ArrayList(SeqLarge),
    repeated_seq_large_hifield: ArrayList(SeqLarge),
    packed_seq_large_lowfield: ArrayList(SeqLarge),
    packed_seq_large_midfield: ArrayList(SeqLarge),
    packed_seq_large_hifield: ArrayList(SeqLarge),
    optional_arbitrary_lowfield: ?Arbitrary,
    optional_arbitrary_midfield: ?Arbitrary,
    optional_arbitrary_hifield: ?Arbitrary,
    repeated_arbitrary_lowfield: ArrayList(Arbitrary),
    repeated_arbitrary_midfield: ArrayList(Arbitrary),
    repeated_arbitrary_hifield: ArrayList(Arbitrary),
    packed_arbitrary_lowfield: ArrayList(Arbitrary),
    packed_arbitrary_midfield: ArrayList(Arbitrary),
    packed_arbitrary_hifield: ArrayList(Arbitrary),
    other_field: ?i32,

    pub const _desc_table = .{
        .optional_seq_small_0_lowfield = fd(1, .{ .Varint = .Simple }),
        .optional_seq_small_0_midfield = fd(1001, .{ .Varint = .Simple }),
        .optional_seq_small_0_hifield = fd(1000001, .{ .Varint = .Simple }),
        .repeated_seq_small_0_lowfield = fd(2, .{ .List = .{ .Varint = .Simple }}),
        .repeated_seq_small_0_midfield = fd(1002, .{ .List = .{ .Varint = .Simple }}),
        .repeated_seq_small_0_hifield = fd(1000002, .{ .List = .{ .Varint = .Simple }}),
        .packed_seq_small_0_lowfield = fd(3, .{ .PackedList = .{ .Varint = .Simple }}),
        .packed_seq_small_0_midfield = fd(1003, .{ .PackedList = .{ .Varint = .Simple }}),
        .packed_seq_small_0_hifield = fd(1000003, .{ .PackedList = .{ .Varint = .Simple }}),
        .optional_seq_small_1_lowfield = fd(4, .{ .Varint = .Simple }),
        .optional_seq_small_1_midfield = fd(1004, .{ .Varint = .Simple }),
        .optional_seq_small_1_hifield = fd(1000004, .{ .Varint = .Simple }),
        .repeated_seq_small_1_lowfield = fd(5, .{ .List = .{ .Varint = .Simple }}),
        .repeated_seq_small_1_midfield = fd(1005, .{ .List = .{ .Varint = .Simple }}),
        .repeated_seq_small_1_hifield = fd(1000005, .{ .List = .{ .Varint = .Simple }}),
        .packed_seq_small_1_lowfield = fd(6, .{ .PackedList = .{ .Varint = .Simple }}),
        .packed_seq_small_1_midfield = fd(1006, .{ .PackedList = .{ .Varint = .Simple }}),
        .packed_seq_small_1_hifield = fd(1000006, .{ .PackedList = .{ .Varint = .Simple }}),
        .optional_seq_large_lowfield = fd(7, .{ .Varint = .Simple }),
        .optional_seq_large_midfield = fd(1007, .{ .Varint = .Simple }),
        .optional_seq_large_hifield = fd(1000007, .{ .Varint = .Simple }),
        .repeated_seq_large_lowfield = fd(8, .{ .List = .{ .Varint = .Simple }}),
        .repeated_seq_large_midfield = fd(1008, .{ .List = .{ .Varint = .Simple }}),
        .repeated_seq_large_hifield = fd(1000008, .{ .List = .{ .Varint = .Simple }}),
        .packed_seq_large_lowfield = fd(9, .{ .PackedList = .{ .Varint = .Simple }}),
        .packed_seq_large_midfield = fd(1009, .{ .PackedList = .{ .Varint = .Simple }}),
        .packed_seq_large_hifield = fd(1000009, .{ .PackedList = .{ .Varint = .Simple }}),
        .optional_arbitrary_lowfield = fd(10, .{ .Varint = .Simple }),
        .optional_arbitrary_midfield = fd(1010, .{ .Varint = .Simple }),
        .optional_arbitrary_hifield = fd(1000010, .{ .Varint = .Simple }),
        .repeated_arbitrary_lowfield = fd(11, .{ .List = .{ .Varint = .Simple }}),
        .repeated_arbitrary_midfield = fd(1011, .{ .List = .{ .Varint = .Simple }}),
        .repeated_arbitrary_hifield = fd(1000011, .{ .List = .{ .Varint = .Simple }}),
        .packed_arbitrary_lowfield = fd(12, .{ .PackedList = .{ .Varint = .Simple }}),
        .packed_arbitrary_midfield = fd(1012, .{ .PackedList = .{ .Varint = .Simple }}),
        .packed_arbitrary_hifield = fd(1000012, .{ .PackedList = .{ .Varint = .Simple }}),
        .other_field = fd(99, .{ .Varint = .Simple }),
    };

pub const SeqSmall0 = enum(i32) {
   SEQ_SMALL_0_DEFAULT = 0,
   SEQ_SMALL_0_1 = 1,
   SEQ_SMALL_0_2 = 2,
    _,
};


pub const SeqSmall1 = enum(i32) {
   SEQ_SMALL_1_DEFAULT = 1,
   SEQ_SMALL_1_2 = 2,
   SEQ_SMALL_1_3 = 3,
    _,
};


pub const SeqLarge = enum(i32) {
   SEQ_LARGE_DEFAULT = -1,
   SEQ_LARGE_0 = 0,
   SEQ_LARGE_1 = 1,
   SEQ_LARGE_2 = 2,
   SEQ_LARGE_3 = 3,
   SEQ_LARGE_4 = 4,
   SEQ_LARGE_5 = 5,
   SEQ_LARGE_6 = 6,
   SEQ_LARGE_7 = 7,
   SEQ_LARGE_8 = 8,
   SEQ_LARGE_9 = 9,
   SEQ_LARGE_10 = 10,
   SEQ_LARGE_11 = 11,
   SEQ_LARGE_12 = 12,
   SEQ_LARGE_13 = 13,
   SEQ_LARGE_14 = 14,
   SEQ_LARGE_15 = 15,
   SEQ_LARGE_16 = 16,
   SEQ_LARGE_17 = 17,
   SEQ_LARGE_18 = 18,
   SEQ_LARGE_19 = 19,
   SEQ_LARGE_20 = 20,
   SEQ_LARGE_21 = 21,
   SEQ_LARGE_22 = 22,
   SEQ_LARGE_23 = 23,
   SEQ_LARGE_24 = 24,
   SEQ_LARGE_25 = 25,
   SEQ_LARGE_26 = 26,
   SEQ_LARGE_27 = 27,
   SEQ_LARGE_28 = 28,
   SEQ_LARGE_29 = 29,
   SEQ_LARGE_30 = 30,
   SEQ_LARGE_31 = 31,
   SEQ_LARGE_32 = 32,
   SEQ_LARGE_33 = 33,
    _,
};


pub const Arbitrary = enum(i32) {
   ARBITRARY_DEFAULT = -123123,
   ARBITRARY_1 = -123,
   ARBITRARY_2 = 213,
   ARBITRARY_3 = 213213,
   ARBITRARY_MIN = -2147483648,
   ARBITRARY_MAX = 2147483647,
    _,
};



    pub fn encode(self: EnumParseTester, allocator: Allocator) ![]u8 {
        return pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) !EnumParseTester {
        return pb_decode(EnumParseTester, input, allocator);
    }
    pub fn init(allocator: Allocator) EnumParseTester {
        return pb_init(EnumParseTester, allocator);
    }
    pub fn deinit(self: EnumParseTester) void {
        return pb_deinit(self);
    }
};
