const warn = @import("std").debug.warn;
const std = @import("std");
const plugin = @import("google/protobuf/compiler/plugin.pb.zig");
const descriptor = @import("google/protobuf/descriptor.pb.zig");
const mem = std.mem;

const allocator = std.heap.page_allocator;

pub fn main() !void {
    const stdin = &std.io.getStdIn();
    const stdout = &std.io.getStdOut();

    // Read the contents
    const buffer_size = 1024 * 1024 * 10;
    const file_buffer = try stdin.readToEndAlloc(allocator, buffer_size);
    defer allocator.free(file_buffer);

    // plugin
    var request: plugin.CodeGeneratorRequest = try plugin.CodeGeneratorRequest.decode(file_buffer, allocator);

    std.debug.print("Parameter: {s}\n", .{request.parameter orelse "<empty>"});
    std.debug.print("Files to generate:\n", .{});
    for (request.file_to_generate.items) |a| {
        std.debug.print("  {s}\n", .{a});
    }

    var response = plugin.CodeGeneratorResponse.init(allocator);

    std.debug.print("Files:\n", .{});
    for (request.proto_file.items) |proto| {
        const t: descriptor.FileDescriptorProto = proto;
        std.debug.print("  {?s}\n", .{t.name});
        for (t.dependency.items) |dep| {
            std.debug.print("    depends on: {?s}\n", .{dep});
        }

        try response.file.append(try outputFile(request, proto));
    }

    const r = try response.encode(allocator);
    _ = try stdout.write(r);
}

fn outputFile(ctx: plugin.CodeGeneratorRequest, file: descriptor.FileDescriptorProto) !plugin.CodeGeneratorResponse.File {
    var ret = plugin.CodeGeneratorResponse.File.init(allocator);

    ret.name = try std.fmt.allocPrint(allocator, "{?s}.zig", .{file.name});

    var list = std.ArrayList([]const u8).init(allocator);
    errdefer list.deinit();

    try list.append(
        \\// Code generated by protoc-gen-zig
        \\
        \\const std = @import("std");
        \\const mem = std.mem;
        \\const Allocator = mem.Allocator;
        \\const ArrayList = std.ArrayList;
        \\
        \\const protobuf = @import("protobuf");
        \\const FieldDescriptor = protobuf.FieldDescriptor;
        \\const pb_decode = protobuf.pb_decode;
        \\const pb_encode = protobuf.pb_encode;
        \\const pb_deinit = protobuf.pb_deinit;
        \\const pb_init = protobuf.pb_init;
        \\const fd = protobuf.fd;
        \\
    );

    // TODO: imports

    try generateEnums(&list, ctx, file, file.enum_type);
    try generateMessages(&list, ctx, file, file.message_type);

    ret.content = try std.mem.concatWithSentinel(allocator, u8, list.items, 0);
    return ret;
}

fn generateEnums(list: *std.ArrayList([]const u8), ctx: plugin.CodeGeneratorRequest, file: descriptor.FileDescriptorProto, enums: std.ArrayList(descriptor.EnumDescriptorProto)) !void {
    _ = ctx;
    _ = file;

    for (enums.items) |theEnum| {
        const e: descriptor.EnumDescriptorProto = theEnum;
        try list.append(try std.fmt.allocPrint(allocator, "\npub const {s} = enum(i32) {{\n", .{e.name orelse @panic("no enum name")}));

        for (e.value.items) |elem| {
            try list.append(try std.fmt.allocPrint(allocator, "   {s} = {},\n", .{ elem.name orelse @panic("no enum value name"), elem.number orelse 0 }));
        }

        try list.append("    _,\n};\n\n");
    }
}

fn fieldName(name: []const u8) []const u8 {
    if (std.mem.eql(u8, name, "packed")) {
        return "@\"packed\"";
    } else if (std.mem.eql(u8, name, "type")) {
        return "@\"type\"";
    } else if (std.mem.eql(u8, name, "null")) {
        return "@\"null\"";
    } else if (std.mem.eql(u8, name, "error")) {
        return "@\"error\"";
    }
    return name;
}

fn getFieldName(field: descriptor.FieldDescriptorProto) ![]const u8 {
    return fieldName(field.name orelse @panic("no field name"));
}

fn getFieldDescriptor(field: descriptor.FieldDescriptorProto) ![]const u8 {
    return std.fmt.allocPrint(allocator, "fd({?d}, .{{ .List = .String }}, []const u8)", .{field.number});
}

fn generateFieldDescriptor(list: *std.ArrayList([]const u8), ctx: plugin.CodeGeneratorRequest, file: descriptor.FileDescriptorProto, messages: std.ArrayList(descriptor.DescriptorProto), field: descriptor.FieldDescriptorProto) !void {
    _ = messages;
    _ = file;
    _ = ctx;

    const fieldDesc = try getFieldDescriptor(field);
    try list.append(try std.fmt.allocPrint(allocator, "        .{s} = {s},\n", .{ try getFieldName(field), fieldDesc }));
}

fn generateMessages(list: *std.ArrayList([]const u8), ctx: plugin.CodeGeneratorRequest, file: descriptor.FileDescriptorProto, messages: std.ArrayList(descriptor.DescriptorProto)) !void {
    for (messages.items) |message| {
        const m: descriptor.DescriptorProto = message;
        try list.append(try std.fmt.allocPrint(allocator, "\npub const {?s} = struct {{", .{m.name}));
        try generateEnums(list, ctx, file, m.enum_type);

        // field descriptors
        try list.append(
            \\
            \\    pub const _desc_table = .{
            \\
        );

        for (m.field.items) |f| {
            try generateFieldDescriptor(list, ctx, file, m.nested_type, f);
        }

        try list.append(
            \\    };
            \\
        );
        try generateMessages(list, ctx, file, m.nested_type);

        try list.append(try std.fmt.allocPrint(allocator,
            \\
            \\
            \\    pub fn encode(self: {?s}, allocator: Allocator) ![]u8 {{
            \\        return pb_encode(self, allocator);
            \\    }}
            \\    pub fn decode(input: []const u8, allocator: Allocator) !{?s} {{
            \\        return pb_decode({?s}, input, allocator);
            \\    }}
            \\    pub fn init(allocator: Allocator) {?s} {{
            \\        return pb_init({?s}, allocator);
            \\    }}
            \\    pub fn deinit(self: {?s}) void {{
            \\        return pb_deinit(self);
            \\    }}
            \\}};
            \\
        , .{ m.name, m.name, m.name, m.name, m.name, m.name }));
    }
}
