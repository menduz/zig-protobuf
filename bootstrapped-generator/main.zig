const warn = @import("std").debug.warn;
const std = @import("std");
const plugin = @import("google/protobuf/compiler/plugin.pb.zig");
const descriptor = @import("google/protobuf/descriptor.pb.zig");
const mem = std.mem;

const allocator = std.heap.page_allocator;

pub fn main() !void {
    const stdin = &std.io.getStdIn();
    const stdout = &std.io.getStdOut();

    // Read the contents
    const buffer_size = 1024 * 1024 * 10;
    const file_buffer = try stdin.readToEndAlloc(allocator, buffer_size);
    defer allocator.free(file_buffer);

    // plugin
    var request: plugin.CodeGeneratorRequest = try plugin.CodeGeneratorRequest.decode(file_buffer, allocator);

    std.debug.print("Parameter: {s}\n", .{request.parameter orelse "<empty>"});
    std.debug.print("Files to generate:\n", .{});
    for (request.file_to_generate.items) |a| {
        std.debug.print("  {s}\n", .{a});
    }

    var response = plugin.CodeGeneratorResponse.init(allocator);

    std.debug.print("Files:\n", .{});
    for (request.proto_file.items) |proto| {
        const t: descriptor.FileDescriptorProto = proto;
        std.debug.print("  {?s}\n", .{t.name});
        for (t.dependency.items) |dep| {
            std.debug.print("    depends on: {?s}\n", .{dep});
        }

        try response.file.append(try outputFile(request, proto));
    }

    const r = try response.encode(allocator);
    _ = try stdout.write(r);
}

fn outputFile(ctx: plugin.CodeGeneratorRequest, file: descriptor.FileDescriptorProto) !plugin.CodeGeneratorResponse.File {
    var ret = plugin.CodeGeneratorResponse.File.init(allocator);

    ret.name = try std.fmt.allocPrint(allocator, "{?s}.zig", .{file.name});

    var list = std.ArrayList([]const u8).init(allocator);
    errdefer list.deinit();

    try list.append(
        \\// Code generated by protoc-gen-zig
        \\
        \\const std = @import("std");
        \\const mem = std.mem;
        \\const Allocator = mem.Allocator;
        \\const ArrayList = std.ArrayList;
        \\
        \\const protobuf = @import("protobuf");
        \\const FieldDescriptor = protobuf.FieldDescriptor;
        \\const pb_decode = protobuf.pb_decode;
        \\const pb_encode = protobuf.pb_encode;
        \\const pb_deinit = protobuf.pb_deinit;
        \\const pb_init = protobuf.pb_init;
        \\const fd = protobuf.fd;
        \\
    );

    // TODO: imports

    try generateEnums(&list, ctx, file, file.enum_type);
    try generateMessages(&list, ctx, file, file.message_type);

    ret.content = try std.mem.concatWithSentinel(allocator, u8, list.items, 0);
    return ret;
}

fn generateEnums(list: *std.ArrayList([]const u8), ctx: plugin.CodeGeneratorRequest, file: descriptor.FileDescriptorProto, enums: std.ArrayList(descriptor.EnumDescriptorProto)) !void {
    _ = ctx;
    _ = file;

    for (enums.items) |theEnum| {
        const e: descriptor.EnumDescriptorProto = theEnum;

        try list.append(try std.fmt.allocPrint(allocator, "\npub const {s} = enum(i32) {{\n", .{e.name orelse @panic("no enum name")}));

        for (e.value.items) |elem| {
            try list.append(try std.fmt.allocPrint(allocator, "   {s} = {},\n", .{ elem.name orelse @panic("no enum value name"), elem.number orelse 0 }));
        }

        try list.append("    _,\n};\n\n");
    }
}

fn fieldName(name: []const u8) []const u8 {
    if (std.mem.eql(u8, name, "packed")) {
        return "@\"packed\"";
    } else if (std.mem.eql(u8, name, "type")) {
        return "@\"type\"";
    } else if (std.mem.eql(u8, name, "null")) {
        return "@\"null\"";
    } else if (std.mem.eql(u8, name, "error")) {
        return "@\"error\"";
    }
    return name;
}

fn getFieldName(field: descriptor.FieldDescriptorProto) ![]const u8 {
    return fieldName(field.name orelse @panic("no field name"));
}

fn fieldTypeFqn(field: descriptor.FieldDescriptorProto) ![]const u8 {
    return field.type_name orelse @panic("fail");
}

fn isRepeated(field: descriptor.FieldDescriptorProto) bool {
    if (field.label) |l| {
        return l == .LABEL_REPEATED;
    } else {
        return false;
    }
}

fn isPacked(field: descriptor.FieldDescriptorProto) bool {
    if (field.options) |o| {
        return o.@"packed" orelse false;
    } else {
        return false;
    }
}

fn isOptional(field: descriptor.FieldDescriptorProto) bool {
    if (field.label) |l| {
        return l == .LABEL_OPTIONAL;
    } else {
        return false;
    }
}

fn getFieldType(field: descriptor.FieldDescriptorProto) ![]const u8 {
    var prefix: []const u8 = "";

    var postfix: []const u8 = "";

    const repated = isRepeated(field);

    const t = field.type orelse @panic("Field without type");

    if (!repated) {
        // look for optional types
        switch (t) {
            .TYPE_MESSAGE, .TYPE_STRING, .TYPE_BYTES => prefix = "?",
            else => {},
        }
    } else {
        prefix = "ArrayList(";
        postfix = ")";
    }

    const infix: []const u8 = switch (t) {
        .TYPE_SINT32, .TYPE_SFIXED32, .TYPE_INT32 => "i32",
        .TYPE_UINT32, .TYPE_FIXED32 => "u32",
        .TYPE_INT64, .TYPE_SINT64, .TYPE_SFIXED64 => "i64",
        .TYPE_UINT64, .TYPE_FIXED64 => "u64",
        .TYPE_BOOL => "bool",
        .TYPE_DOUBLE => "f64",
        .TYPE_FLOAT => "f32",
        .TYPE_STRING, .TYPE_BYTES => "[]const u8",
        .TYPE_ENUM, .TYPE_MESSAGE => try fieldTypeFqn(field),
        else => {
            std.debug.print("Unrecognized type {}\n", .{t});
            @panic("Unrecognized type");
        },
    };

    return try std.mem.concatWithSentinel(allocator, u8, &.{ prefix, infix, postfix }, 0);
}

fn getFieldTypeDescriptor(field: descriptor.FieldDescriptorProto) ![]const u8 {
    var prefix: []const u8 = "";

    var postfix: []const u8 = "";

    if (isRepeated(field)) {
        if (isPacked(field)) {
            prefix = ".{ .PackedList = ";
        } else {
            prefix = ".{ .List = ";
        }
        postfix = "}";
    }

    const t = field.type orelse @panic("Field without type");

    const infix: []const u8 = switch (t) {
        .TYPE_DOUBLE, .TYPE_FLOAT, .TYPE_SFIXED32, .TYPE_FIXED32, .TYPE_SFIXED64, .TYPE_FIXED64 => ".FixedInt",
        .TYPE_ENUM, .TYPE_UINT32, .TYPE_UINT64, .TYPE_BOOL, .TYPE_INT32, .TYPE_INT64 => ".{ .Varint = .Simple }",
        .TYPE_SINT32, .TYPE_SINT64 => ".{ .Varint = .ZigZagOptimized }",
        .TYPE_STRING, .TYPE_BYTES => ".String",
        .TYPE_MESSAGE => ".{ .SubMessage = {} }",
        else => {
            std.debug.print("Unrecognized type {}\n", .{t});
            @panic("Unrecognized type");
        },
    };

    return try std.mem.concatWithSentinel(allocator, u8, &.{ prefix, infix, postfix }, 0);
}

fn getFieldDescriptor(field: descriptor.FieldDescriptorProto) ![]const u8 {
    var typeStr = try getFieldType(field);
    var descStr = try getFieldTypeDescriptor(field);
    return std.fmt.allocPrint(allocator, "fd({?d}, {s}, {s})", .{ field.number, descStr, typeStr });
}

fn generateFieldDescriptor(list: *std.ArrayList([]const u8), ctx: plugin.CodeGeneratorRequest, file: descriptor.FileDescriptorProto, messages: std.ArrayList(descriptor.DescriptorProto), field: descriptor.FieldDescriptorProto) !void {
    _ = messages;
    _ = file;
    _ = ctx;

    const fieldDesc = try getFieldDescriptor(field);
    try list.append(try std.fmt.allocPrint(allocator, "        .{s} = {s},\n", .{ try getFieldName(field), fieldDesc }));
}

fn generateMessages(list: *std.ArrayList([]const u8), ctx: plugin.CodeGeneratorRequest, file: descriptor.FileDescriptorProto, messages: std.ArrayList(descriptor.DescriptorProto)) !void {
    for (messages.items) |message| {
        const m: descriptor.DescriptorProto = message;
        try list.append(try std.fmt.allocPrint(allocator, "\npub const {?s} = struct {{", .{m.name}));
        try generateEnums(list, ctx, file, m.enum_type);

        // field descriptors
        try list.append(
            \\
            \\    pub const _desc_table = .{
            \\
        );

        for (m.field.items) |f| {
            try generateFieldDescriptor(list, ctx, file, m.nested_type, f);
        }

        try list.append(
            \\    };
            \\
        );
        try generateMessages(list, ctx, file, m.nested_type);

        try list.append(try std.fmt.allocPrint(allocator,
            \\
            \\
            \\    pub fn encode(self: {?s}, allocator: Allocator) ![]u8 {{
            \\        return pb_encode(self, allocator);
            \\    }}
            \\    pub fn decode(input: []const u8, allocator: Allocator) !{?s} {{
            \\        return pb_decode({?s}, input, allocator);
            \\    }}
            \\    pub fn init(allocator: Allocator) {?s} {{
            \\        return pb_init({?s}, allocator);
            \\    }}
            \\    pub fn deinit(self: {?s}) void {{
            \\        return pb_deinit(self);
            \\    }}
            \\}};
            \\
        , .{ m.name, m.name, m.name, m.name, m.name, m.name }));
    }
}
